<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>diskpy.ICgen package &mdash; diskpy  documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="diskpy  documentation" href="index.html" />
    <link rel="up" title="diskpy package" href="diskpy.html" />
    <link rel="next" title="diskpy.ICgen.sigprofiles package" href="diskpy.ICgen.sigprofiles.html" />
    <link rel="prev" title="diskpy package" href="diskpy.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="diskpy.ICgen.sigprofiles.html" title="diskpy.ICgen.sigprofiles package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="diskpy.html" title="diskpy package"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">diskpy  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="diskpy.html" accesskey="U">diskpy package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="diskpy-icgen-package">
<h1>diskpy.ICgen package<a class="headerlink" href="#diskpy-icgen-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="diskpy.ICgen.sigprofiles.html">diskpy.ICgen.sigprofiles package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="diskpy.ICgen.sigprofiles.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="diskpy.ICgen.sigprofiles.html#module-diskpy.ICgen.sigprofiles.powerlaw">diskpy.ICgen.sigprofiles.powerlaw module</a></li>
<li class="toctree-l2"><a class="reference internal" href="diskpy.ICgen.sigprofiles.html#module-diskpy.ICgen.sigprofiles">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-diskpy.ICgen.AddBinary">
<span id="diskpy-icgen-addbinary-module"></span><h2>diskpy.ICgen.AddBinary module<a class="headerlink" href="#module-diskpy.ICgen.AddBinary" title="Permalink to this headline">¶</a></h2>
<p>David Fleming</p>
<p>Note:  All functions in the module only interact with the binary system itself.  For functions that work with
the disk or binary + disk, consult binaryUtils.py</p>
<p>Has all functions and utilities required to initialize/analyze binary star system</p>
<p>Initial input:
-Snapshot with central star of mass M (in Msol) located at (0,0,0)
in tipsy format (works with pynbody simArray data structure)
-Period (days), eccentricity of binary system</p>
<p>What This does:
Converts central star into 2 stars 1,2 under following conditions:</p>
<blockquote>
<div>m1 + m2 = M (divide mass into 2 stars)
Center of Mass of stars remains at (0,0,0)</div></blockquote>
<p>Used to initialize velocites of binary system given Keplerian relations
Also has additional functions to initialize and analyze binary system</p>
<p>#!!! Note: v_unit_vel will always be 29.785598165 km/s when m_unit = Msol and r_unit = 1 AU in kpc!!!</p>
<dl class="function">
<dt id="diskpy.ICgen.AddBinary.aToP">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">aToP</code><span class="sig-paren">(</span><em>a=1</em>, <em>M=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#aToP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.aToP" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a semimajor axis (au), convert into period (in days) given Kepler law</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : float</p>
<blockquote>
<div><p>semimajor axis [au]</p>
</div></blockquote>
<p><strong>M</strong> : float</p>
<blockquote>
<div><p>mass of system [Msol]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Period</strong> : float</p>
<blockquote class="last">
<div><p>[days]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.accretionEDot">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">accretionEDot</code><span class="sig-paren">(</span><em>Binary</em>, <em>M_dot</em>, <em>dt</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#accretionEDot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.accretionEDot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a Binary object and an accretion rate (assumed to be in M_sol/yr), compute the theoretical rate of change of the
binary&#8217;s eccentricity in 1/second.
Assumptions:
-radius, velocity of binary nearly constant over accretion (found to more or less apply via empirical measurements)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Binary: binary object class</strong></p>
<p><strong>Mdot: float</strong></p>
<blockquote>
<div><p>accretion rate in M_sol/yr</p>
</div></blockquote>
<p><strong>dt: float</strong></p>
<blockquote>
<div><p>time interval</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">de/dt: float</p>
<blockquote class="last">
<div><p>change in eccentricity in 1/second</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.binaryPrecession">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">binaryPrecession</code><span class="sig-paren">(</span><em>s</em>, <em>r_in</em>, <em>r_out</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#binaryPrecession"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.binaryPrecession" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the period of the binary precession due to an axisymmetric disk (!!!)
given by Rafikov 2013.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>s</strong> : Tipsy snapshot</p>
<p><strong>r_in, r_out</strong> : float</p>
<blockquote>
<div><p>inner and outer radii of the circumbinary disk [AU]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>T</strong> : SimArray</p>
<blockquote class="last">
<div><p>Period of binary argument of periastron precession in yr</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcArgPeri">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcArgPeri</code><span class="sig-paren">(</span><em>x1=1</em>, <em>x2=0</em>, <em>v1=1</em>, <em>v2=0</em>, <em>m1=1</em>, <em>m2=1</em>, <em>flag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcArgPeri"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcArgPeri" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody arrays for positions and velocity of primary and secondary bodies
and masses, calculates the eccentricity vector in the reduced two body system.
Usage note: Intended for binary system, but pass x2 = v2 = 0 to use with any
location in the disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Assumed as pynbody SimArrays [preferred units]</strong></p>
<p><strong>x1,x2</strong> : SimArrays</p>
<blockquote>
<div><p>Primary and secondary position arrays [AU]</p>
</div></blockquote>
<p><strong>v1,v2</strong> : SimArrays</p>
<blockquote>
<div><p>Primary and secondary velocity arrays [km/s]</p>
</div></blockquote>
<p><strong>m1, m2</strong> : SimArrays</p>
<blockquote>
<div><p>Primary and secondary masses [Msol]</p>
</div></blockquote>
<p><strong>Flag</strong> : bool</p>
<blockquote>
<div><p>Whether or not to internally convert to cgs units</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">w: float</p>
<blockquote class="last">
<div><p>Argument of pericenter in degrees</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcCOM">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcCOM</code><span class="sig-paren">(</span><em>m1=0.5</em>, <em>m2=0.5</em>, <em>x1=1</em>, <em>x2=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcCOM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcCOM" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody arrays for the mass and position of the two binary stars,
function calculates the CoM of the two particles in order to check that
it&#8217;s still roughly 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>(as pynbody SimArrays)</strong></p>
<p><strong>m1, m2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary mass arrays (in Msol)</p>
</div></blockquote>
<p><strong>x1, x2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary position arrays (in AU)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">center of mass: array</p>
<blockquote class="last">
<div><p>Center of mass position vector (numpy array in AU)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcCircularFrequency">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcCircularFrequency</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em>, <em>v1</em>, <em>v2</em>, <em>m1</em>, <em>m2</em>, <em>flag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcCircularFrequency"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcCircularFrequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody arrays for positions and velocity of primary and secondary bodies
and masses, calculates the circular frequency in the reduced two body system.
Usage note: Intended for binary system, but pass x2 = v2 = 0 to use with any
location in the disk.</p>
<p>omega = (L_z)/(R^2) which assumes spherical symmetry (ok assumption here)
L = sqrt(G*M*a*(1-e^2) for ~Keplerian</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Assumed as pynbody SimArrays in simulation units (AU, scaled velocity, etc)</strong></p>
<p><strong>x1,x2: arrays</strong></p>
<blockquote>
<div><p>Primary and secondary position arrays (in AU)</p>
</div></blockquote>
<p><strong>v1, v2: arrays</strong></p>
<blockquote>
<div><p>Primary and secondary velocity arrays (km/s)</p>
</div></blockquote>
<p><strong>m1, m2: floats</strong></p>
<blockquote>
<div><p>Primary and secondary masses (Msol)</p>
</div></blockquote>
<p><strong>Flag: Whether or not to internally convert to cgs units</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">omega: float</p>
<blockquote class="last">
<div><p>Circular frequency in 1/days</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcCriticalRadius">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcCriticalRadius</code><span class="sig-paren">(</span><em>a=1</em>, <em>e=0</em>, <em>m1=0.5</em>, <em>m2=0.5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcCriticalRadius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcCriticalRadius" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the approximate bounds for where we would expect a planet to form
given the conditions of a circumbinary disk around a short-period binary system.
Calculates based on best fit from Holman&amp;Wiegert+1999 (outer/P-type region)
Assumes m1 ~ m2 and NOT m1 &gt;&gt; m2 or m2 &gt;&gt; m1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a: float</strong></p>
<blockquote>
<div><p>Semimajor axis a of the binary system (au)</p>
</div></blockquote>
<p><strong>e: float</strong></p>
<blockquote>
<div><p>Eccentricity e of binary system</p>
</div></blockquote>
<p><strong>m1, m2: floats</strong></p>
<blockquote>
<div><p>Masses of binary components m1, m2 (Msol)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">ac, pmac: floats</p>
<blockquote class="last">
<div><p>Lower bounds for circumbinary planet&#8217;s distace from binary COM and error terms of the following form:
ac, pmac (error bounds are symmetric) both in au</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcEcc">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcEcc</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em>, <em>v1</em>, <em>v2</em>, <em>m1</em>, <em>m2</em>, <em>flag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcEcc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcEcc" title="Permalink to this definition">¶</a></dt>
<dd><p>Given as pynbody arrays the masses of the binary system, arrays of the positions and velocities, compute
its orbital eccentricity.</p>
<p>Calculates e using following: e = sqrt(1 + (2*e*h^2)/(mu^2)
for h = r x v, mu = G*(m1+m2), e = (v^2)/2 - (mu/<a href="#id3"><span class="problematic" id="id4">|r|</span></a>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>All inputs expected to be pynbody simArrays!!!</strong></p>
<p><strong>x1, x2: SimArrays</strong></p>
<blockquote>
<div><p>Position arrays of primary and secondary x1, x2 (in AU)</p>
</div></blockquote>
<p><strong>v1, v2: SimArrays</strong></p>
<blockquote>
<div><p>Velocity arrays of primary and secondary v1, v2 (in km/s)</p>
</div></blockquote>
<p><strong>m1, m2: SimArrays</strong></p>
<blockquote>
<div><p>Masses of primary and secondary m1, m2 (in Msol)</p>
</div></blockquote>
<p><strong>Flag: bool</strong></p>
<blockquote>
<div><p>Whether or not to internally convert to cgs units</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">e: float</p>
<blockquote class="last">
<div><p>Scalar eccentricity of binary system.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcEccVector">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcEccVector</code><span class="sig-paren">(</span><em>x1=1</em>, <em>x2=0</em>, <em>v1=1</em>, <em>v2=0</em>, <em>m1=1</em>, <em>m2=1</em>, <em>flag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcEccVector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcEccVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody arrays for positions and velocity of primary and secondary bodies
and masses, calculates the eccentricity vector in the reduced two body system.
Usage note: Intended for binary system, but pass x2 = v2 = 0 to use with any
location in the disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x1,x2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary position arrays [length]</p>
</div></blockquote>
<p><strong>v1, v2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary velocity arrays [velocity]</p>
</div></blockquote>
<p><strong>m1,m2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary masses [mass]</p>
</div></blockquote>
<p><strong>Flag: bool</strong></p>
<blockquote>
<div><p>Whether or not to internally convert to cgs units</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Ecc: array</p>
<blockquote class="last">
<div><p>Eccentricity vector in cgs</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcEccentricAnomaly">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcEccentricAnomaly</code><span class="sig-paren">(</span><em>x1=1</em>, <em>x2=0</em>, <em>v1=1</em>, <em>v2=0</em>, <em>m1=1</em>, <em>m2=1</em>, <em>flag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcEccentricAnomaly"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcEccentricAnomaly" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody arrays for positions and velocity of primary and secondary bodies
and masses, calculates the eccentric anomaly in the reduced two body system.
Usage note: Intended for binary system, but pass x2 = v2 = 0 to use with any
location in the disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Assumed as pynbody SimArrays [preferred units]</strong></p>
<p><strong>x1,x2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary position arrays [AU]</p>
</div></blockquote>
<p><strong>v1,v2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary velocity arrays [km/s]</p>
</div></blockquote>
<p><strong>m1, m2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary masses [Msol]</p>
</div></blockquote>
<p><strong>Flag: bool</strong></p>
<blockquote>
<div><p>Whether or not to internally convert to cgs units</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">E: float</p>
<blockquote class="last">
<div><p>Eccentric anomaly in degrees</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcInc">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcInc</code><span class="sig-paren">(</span><em>x1=1</em>, <em>x2=0</em>, <em>v1=1</em>, <em>v2=0</em>, <em>flag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcInc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcInc" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody arrays for positions and velocities of primary and secondaries bodies and masses in
a binary orbit, calculate&#8217;s the orbit&#8217;s inclination. (Given: Orbit starts in xy plane)</p>
<p>i = arccos(h_z/<a href="#id5"><span class="problematic" id="id6">|h|</span></a>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>as pynbody SimArrays [preferred units]</strong></p>
<p><strong>x1,x2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary position arrays [AU]</p>
</div></blockquote>
<p><strong>v1, v2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary velocity arrays [km/s]</p>
</div></blockquote>
<p><strong>Flag: bool</strong></p>
<blockquote>
<div><p>Whether or not to internally convert to cgs units</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">i: float</p>
<blockquote class="last">
<div><p>Inclination in degrees</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcLongOfAscNode">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcLongOfAscNode</code><span class="sig-paren">(</span><em>x1=1</em>, <em>x2=0</em>, <em>v1=1</em>, <em>v2=0</em>, <em>flag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcLongOfAscNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcLongOfAscNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody arrays for positions and velocity of primary and secondary bodies
and masses, calculates the binary&#8217;s longitude of the ascending node Omega.
Usage note: Intended for binary system, but pass x2 = v2 = 0 to use with any
location in the disk.</p>
<p>Calculates Omega using the following: Omega = arccos(n_x/<a href="#id7"><span class="problematic" id="id8">|n|</span></a>) n_y &gt; 0
Omega = 2*pi - arccos(n_x/<a href="#id9"><span class="problematic" id="id10">|n|</span></a>) n_y &lt; 0
where n = (0,0,1) x h for h = r x v</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Assumed as pynbody SimArrays in simulation units (AU, scaled velocity, etc)</strong></p>
<p><strong>x1,x2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary position arrays [AU]</p>
</div></blockquote>
<p><strong>v1,v2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary velocity arrays [km/s]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Omega: float</p>
<blockquote class="last">
<div><p>longitude of the ascending node in degrees</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcMeanAnomaly">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcMeanAnomaly</code><span class="sig-paren">(</span><em>x1=1</em>, <em>x2=0</em>, <em>v1=1</em>, <em>v2=0</em>, <em>m1=1</em>, <em>m2=1</em>, <em>flag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcMeanAnomaly"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcMeanAnomaly" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody arrays for positions and velocity of primary and secondary bodies
and masses, calculates the Mean anomaly in the reduced two body system.
Usage note: Intended for binary system, but pass x2 = v2 = 0 to use with any
location in the disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Assumed as pynbody SimArrays [preferred units]</strong></p>
<p><strong>x1,x2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary position arrays [AU]</p>
</div></blockquote>
<p><strong>v1,v2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary velocity arrays [km/s]</p>
</div></blockquote>
<p><strong>m1, m2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary masses [Msol]</p>
</div></blockquote>
<p><strong>Flag: bool</strong></p>
<blockquote>
<div><p>Whether or not to internally convert to cgs units</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">M: float</p>
<blockquote class="last">
<div><p>Mean anomaly in degrees</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcMeanMotion">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcMeanMotion</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em>, <em>v1</em>, <em>v2</em>, <em>m1</em>, <em>m2</em>, <em>flag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcMeanMotion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcMeanMotion" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody arrays for positions and velocity of primary and secondary bodies
and masses, calculates the Mean motion in the reduced two body system.
Usage note: Intended for binary system, but pass x2 = v2 = 0 to use with any
location in the disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Assumed as pynbody SimArrays [preferred units]</strong></p>
<p><strong>x1,x2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary position arrays [AU]</p>
</div></blockquote>
<p><strong>v1,v2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary velocity arrays [km/s]</p>
</div></blockquote>
<p><strong>m1, m2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary masses [Msol]</p>
</div></blockquote>
<p><strong>Flag: bool</strong></p>
<blockquote>
<div><p>Whether or not to internally convert to cgs units</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">n: SimArray</p>
<blockquote class="last">
<div><p>Mean motion in 1/s</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcOrbitalElements">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcOrbitalElements</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em>, <em>v1</em>, <em>v2</em>, <em>m1</em>, <em>m2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcOrbitalElements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcOrbitalElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Given as pynbody SimArrays the cental mass(es), the coodinate(s) and velocity(ies) of a CCW orbiting object,
return the following orbital elements: eccentricity, semimajor axis, inclination, longitude of ascending node,
argument of periapsis, and true anomaly.  This function is designed to work for a binary star system but is
general enough to also work for a ~massless gas particle orbiting around a central quasi-Keplerian mass.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>All input assumed to be in simulation units and are converted to desired units internally.</strong></p>
<p><strong>x1,x2: position arrays in AU (x2 = 0 for gas particle case)</strong></p>
<p><strong>v1,v2: velocity arrays in km/s (v2 = 0 for gas particle case)</strong></p>
<p><strong>m1,m2: Central masses in Msol</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">e: float</p>
<blockquote>
<div><p>Eccentricity (unitless)</p>
</div></blockquote>
<p>a: float</p>
<blockquote>
<div><p>Semimajor Axis in Au</p>
</div></blockquote>
<p>i: float</p>
<blockquote>
<div><p>Inclination in degrees</p>
</div></blockquote>
<p>Omega: float</p>
<blockquote>
<div><p>Longitude of Ascending node in degrees</p>
</div></blockquote>
<p>w: float</p>
<blockquote>
<div><p>Argument of Periapsis in degrees</p>
</div></blockquote>
<p>nu: float</p>
<blockquote class="last">
<div><p>True Anomaly in degrees</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcPositions">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcPositions</code><span class="sig-paren">(</span><em>M=1</em>, <em>a=1</em>, <em>e=0</em>, <em>p=0.5</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcPositions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcPositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Given total mass of system M, semimajor axis a, and percentage of total mass contained in primary star p,
calculate positions of binary components keep COM at origin
(ex: If 1Msol system and MPri = Msec = 0.5 -&gt; M =1 -&gt; p = 0.5)
Assume stars start a perihelion</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>M: float</strong></p>
<blockquote>
<div><p>Total mass of system (Msol)</p>
</div></blockquote>
<p><strong>a: float</strong></p>
<blockquote>
<div><p>Semimajor axis (au)</p>
</div></blockquote>
<p><strong>e: float</strong></p>
<blockquote>
<div><p>eccentricity</p>
</div></blockquote>
<p><strong>p: float</strong></p>
<blockquote>
<div><p>% of total mass contained in primary (m1)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">x1, x2: float</p>
<blockquote class="last">
<div><p>Semimajor axes of binary stars assuming that they start at perihelion.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcRocheLobe">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcRocheLobe</code><span class="sig-paren">(</span><em>q</em>, <em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcRocheLobe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcRocheLobe" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the mass ratio q = m1/m2 and the semimajor axis in AU, compute the radius of the Roche lobe
around m1 given the Eggleton approximation <a class="reference external" href="http://en.wikipedia.org/wiki/Roche_lobe">http://en.wikipedia.org/wiki/Roche_lobe</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q: float</strong></p>
<blockquote>
<div><p>Binary mass ratio q = m1/m2</p>
</div></blockquote>
<p><strong>a: float</strong></p>
<blockquote>
<div><p>Binary semimajor axis a (in AU)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">r: float</p>
<blockquote class="last">
<div><p>Radius of Roche lobe around m1 (in AU)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcSemi">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcSemi</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em>, <em>v1</em>, <em>v2</em>, <em>m1</em>, <em>m2</em>, <em>flag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcSemi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcSemi" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody arrays for positions and velocity of primary and secondary bodies
and masses, calculates the binary&#8217;s semimajor axis.</p>
<p>Calculates a using the following: a = -mu/(2*e)
where mu = G*(m1+m2) and e = (v^2)/2 - (mu/<a href="#id11"><span class="problematic" id="id12">|r|</span></a>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>(as pynbody SimArrays!)</strong></p>
<p><strong>x1,x2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary position arrays [AU]</p>
</div></blockquote>
<p><strong>v1,v2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary velocity arrays [km/s]</p>
</div></blockquote>
<p><strong>m1,m2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary masses [Msol]</p>
</div></blockquote>
<p><strong>Flag: bool</strong></p>
<blockquote>
<div><p>Whether or not to internally convert to cgs units</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a: float</p>
<blockquote class="last">
<div><p>semimajor axis of binary orbit in AU</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcTrueAnomaly">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcTrueAnomaly</code><span class="sig-paren">(</span><em>x1=1</em>, <em>x2=0</em>, <em>v1=1</em>, <em>v2=0</em>, <em>m1=1</em>, <em>m2=1</em>, <em>flag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcTrueAnomaly"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcTrueAnomaly" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody arrays for positions and velocity of primary and secondary bodies
and masses, calculates the true anomaly in the reduced two body system.
Usage note: Intended for binary system, but pass x2 = v2 = 0 to use with any
location in the disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Assumed as pynbody SimArrays [preferred units]</strong></p>
<p><strong>x1,x2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary position arrays [AU]</p>
</div></blockquote>
<p><strong>v1,v2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary velocity arrays [km/s]</p>
</div></blockquote>
<p><strong>m1, m2: SimArrays</strong></p>
<blockquote>
<div><p>Primary and secondary masses [Msol]</p>
</div></blockquote>
<p><strong>Flag: bool</strong></p>
<blockquote>
<div><p>Whether or not to internally convert to cgs units</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">nu: float</p>
<blockquote class="last">
<div><p>True anomaly in degrees</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.calcV">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">calcV</code><span class="sig-paren">(</span><em>m1=0.5</em>, <em>m2=0.5</em>, <em>a=1</em>, <em>e=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#calcV"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.calcV" title="Permalink to this definition">¶</a></dt>
<dd><p>Given total mass M, postions of stars at perihelion x1, x2, and eccentricity e, calculate the velocities of the stars
assuming that they are located at the perihelion and rotate in same direction as disk (CCW)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>m1, m2: floats</strong></p>
<blockquote>
<div><p>masses of primary and secondary (Msol)</p>
</div></blockquote>
<p><strong>x1, x2: floats</strong></p>
<blockquote>
<div><p>are semimajor axes of primary and secondary (au)</p>
</div></blockquote>
<p><strong>e: float</strong></p>
<blockquote>
<div><p>eccentricity</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">v1, v2: floats</p>
<blockquote class="last">
<div><p>velocities of m1, m2 in km/s oriented for CCW rotation (in xy plane)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.computeLenAx">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">computeLenAx</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#computeLenAx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.computeLenAx" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an numpy array, check to see if it&#8217;s length is 1 (aka it&#8217;s a float, or int or whatever) or otherwise and return
it&#8217;s length and the axis over which calculations like normalization and cross product is to be taken.  This function
is useful when you expect data arrays of the form x = [n,3] with weird combinations of lists/numpy arrays</p>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.dotProduct">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">dotProduct</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#dotProduct"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.dotProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Given n x m numpy arrays, compute the dot product row-wise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a,b: nxm numpy array</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dot product: numpy array</p>
<blockquote class="last">
<div><p>n rows containing dot products</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.initializeBinary">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">initializeBinary</code><span class="sig-paren">(</span><em>a</em>, <em>e</em>, <em>i</em>, <em>Omega</em>, <em>w</em>, <em>M</em>, <em>m1</em>, <em>m2</em>, <em>angleFlag=True</em>, <em>scaleFlag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#initializeBinary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.initializeBinary" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the initial Kepler orbital parameters, compute the Cartesian positions and velocities
for 2 mutually orbiting stars (binaries!).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Keplerian orbital elements: floats</strong></p>
<blockquote>
<div><p>in Au, degrees (see above for more details)</p>
</div></blockquote>
<p><strong>m1,m2: floats</strong></p>
<blockquote>
<div><p>Masses of central objects (Msol)</p>
</div></blockquote>
<p><strong>angleFlag: bool</strong></p>
<blockquote>
<div><p>whether or not to convert from degrees-&gt;radians (True = convert)</p>
</div></blockquote>
<p><strong>scaleFlag: bool</strong></p>
<blockquote>
<div><p>whether or not to put v in sim units (True = do it/default option)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">x1, x2: array</p>
<blockquote>
<div><p>Positions of 2 objects about origin (Au)</p>
</div></blockquote>
<p>v1, v2: array</p>
<blockquote class="last">
<div><p>Velocities of 2 objects about origin (km/s in Sim Units)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.keplerToCartesian">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">keplerToCartesian</code><span class="sig-paren">(</span><em>a</em>, <em>e</em>, <em>i</em>, <em>Omega</em>, <em>w</em>, <em>M</em>, <em>m1</em>, <em>m2</em>, <em>angleFlag=True</em>, <em>scaleFlag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#keplerToCartesian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.keplerToCartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the Keplerian orbital elements, compute the cartesian coordinates of the object orbiting
in the reduced mass frame.  Note: Requires all angles in degrees unless noted.</p>
<p>Note: A little redudant that I compute M when I typically already know the true anomaly nu, but most
other schemes know M initially instead of nu so I&#8217;ll keep it for compatibility&#8217;s sake.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a: float</strong></p>
<blockquote>
<div><p>Semimajor axis (AU)</p>
</div></blockquote>
<p><strong>e: float</strong></p>
<blockquote>
<div><p>Eccentricity</p>
</div></blockquote>
<p><strong>i: float</strong></p>
<blockquote>
<div><p>inclination (degrees)</p>
</div></blockquote>
<p><strong>Omega: float</strong></p>
<blockquote>
<div><p>Longitude of Ascending Node (degrees)</p>
</div></blockquote>
<p><strong>w: float</strong></p>
<blockquote>
<div><p>Argument of Pericenter (degrees)</p>
</div></blockquote>
<p><strong>M: float</strong></p>
<blockquote>
<div><p>Mean Anomaly (degrees)</p>
</div></blockquote>
<p><strong>m1, m2: float</strong></p>
<blockquote>
<div><p>Masses of central object(s) (Msol)</p>
</div></blockquote>
<p><strong>angleFlag, scaleFlag: bools</strong></p>
<blockquote>
<div><p>Tells code to convert degrees-&gt;rad and/or scale velocity to sim units, respectively</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">x: numpy array</p>
<blockquote>
<div><p>Position array of the object in reduced mass frame (AU)</p>
</div></blockquote>
<p>v: numpy array</p>
<blockquote class="last">
<div><p>velocity array (km/s) with VEL_UNIT scaling factor optional</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.pToA">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">pToA</code><span class="sig-paren">(</span><em>period=1</em>, <em>M=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#pToA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.pToA" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts period (in days) into semimajor axis (in au) given Kepler law</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Period</strong> : float</p>
<blockquote>
<div><p>[days]</p>
</div></blockquote>
<p><strong>M</strong> : float</p>
<blockquote>
<div><p>COM mass [Msol]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Semimajor axis a (au)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.reduceToPhysical">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">reduceToPhysical</code><span class="sig-paren">(</span><em>r</em>, <em>v</em>, <em>m1</em>, <em>m2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#reduceToPhysical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.reduceToPhysical" title="Permalink to this definition">¶</a></dt>
<dd><p>Function converts from reduced mass coordinates to physical, origin-centered coords
Works for arbitrary units, number of objects with coordinates as long as m1+m2 = central mass.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>r: array</strong></p>
<blockquote>
<div><p>radius vector</p>
</div></blockquote>
<p><strong>v: array</strong></p>
<blockquote>
<div><p>velocity vector</p>
</div></blockquote>
<p><strong>m1, m2: floats</strong></p>
<blockquote>
<div><p>mass of central object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">x1, x2: numpy arrays</p>
<blockquote>
<div><p>position vectors of 2 mutually orbiting objects</p>
</div></blockquote>
<p>v1, v2:numpy arrays</p>
<blockquote class="last">
<div><p>velocity vectors of 2 mutually orbiting objects</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.AddBinary.trueToMean">
<code class="descclassname">diskpy.ICgen.AddBinary.</code><code class="descname">trueToMean</code><span class="sig-paren">(</span><em>nu</em>, <em>e</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/AddBinary.html#trueToMean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.AddBinary.trueToMean" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the true anomaly nu in degrees and the eccentricity e, compute the mean anomaly M in degrees.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nu: float</strong></p>
<blockquote>
<div><p>True anomaly (degrees)</p>
</div></blockquote>
<p><strong>e: float</strong></p>
<blockquote>
<div><p>eccentricity</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">M: float</p>
<blockquote class="last">
<div><p>mean anomaly (degrees)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.ICgen">
<span id="diskpy-icgen-icgen-module"></span><h2>diskpy.ICgen.ICgen module<a class="headerlink" href="#module-diskpy.ICgen.ICgen" title="Permalink to this headline">¶</a></h2>
<p>Created on Wed Mar 12 12:48:33 2014</p>
<p>&#64;author: ibackus</p>
<dl class="class">
<dt id="diskpy.ICgen.ICgen.IC">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.ICgen.</code><code class="descname">IC</code><span class="sig-paren">(</span><em>r=None</em>, <em>sigma=None</em>, <em>CDF=None</em>, <em>profile_kind=None</em>, <em>settings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#IC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen.IC" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the IC class.</p>
<p>INITIALIZING NEW INITIAL CONDITIONS</p>
<p># Initialize a blank IC object (with no surface density profile yet made)</p>
<p>IC = ICgen.IC()</p>
<p># Initialize an IC object and surface density profile using default settings</p>
<p>IC = ICgen.IC(profile_kind=&#8217;powerlaw&#8217;)
IC = ICgen.IC(profile_kind=&#8217;MQWS&#8217;)</p>
<p># Initialize IC object from 1-D SimArrays r, sigma (surface density)</p>
<p>IC = ICgen.IC(r, sigma)</p>
<p>Optionally, the CDF for the surface density profile can be supplied to
speed up generation of sigma.  To do that:</p>
<p>IC = ICgen.IC(r, sigma, CDF)</p>
<p>Or, the input can be a the filename of a pickled dictionary containing
&#8216;r&#8217;, &#8216;sigma&#8217;, and optionally &#8216;CDF&#8217;</p>
<p>Settings can also be entered manually if needed</p>
<p>settings = pickle.load(open(&#8216;settings.p&#8217;,&#8217;r&#8217;))
IC = ICgen.IC(settings = settings)</p>
<p>GENERATING INITIAL CONDITIONS</p>
<dl class="method">
<dt id="diskpy.ICgen.ICgen.IC.Qest">
<code class="descname">Qest</code><span class="sig-paren">(</span><em>r=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#IC.Qest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen.IC.Qest" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate Toomre Q at r (optional) for ICs, assuming omega=epicyclic
frequency.  Ignores disk self-gravity</p>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.ICgen.IC.generate">
<code class="descname">generate</code><span class="sig-paren">(</span><em>restart=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#IC.generate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen.IC.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs through all the steps to generate a set of initial conditions</p>
<p>IF restart=True, it picks up at the last completed step</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.ICgen.Qest">
<code class="descclassname">diskpy.ICgen.ICgen.</code><code class="descname">Qest</code><span class="sig-paren">(</span><em>ICobj</em>, <em>r=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#Qest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen.Qest" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate Toomre Q at r (optional) for ICs, assuming omega=epicyclic
frequency.  Ignores disk self-gravity</p>
</dd></dl>

<dl class="class">
<dt id="diskpy.ICgen.ICgen.add">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.ICgen.</code><code class="descname">add</code><span class="sig-paren">(</span><em>ICobj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains modules to load data/parameters</p>
<dl class="method">
<dt id="diskpy.ICgen.ICgen.add.rho">
<code class="descname">rho</code><span class="sig-paren">(</span><em>rho_dict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#add.rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen.add.rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a rho object and stores it in ICobj.rho</p>
<dl class="docutils">
<dt>rho_dict should be a dictionary containing:</dt>
<dd>&#8216;z&#8217;:    1D array of z values
&#8216;r&#8217;:    1D array of r values
&#8216;rho&#8217;:  2D array of rho evaluated at z,r</dd>
</dl>
<p>Exaple:</p>
<p>rho_dict = pickle.load(open(&#8216;rhofile.p&#8217;, &#8216;rb&#8217;)) # Load up a rho dict
ICobj.add.rho(rho_dict)     # create ICobj.rho</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.ICgen.load">
<code class="descclassname">diskpy.ICgen.ICgen.</code><code class="descname">load</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen.load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="diskpy.ICgen.ICgen.maker">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.ICgen.</code><code class="descname">maker</code><span class="sig-paren">(</span><em>ICobj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#maker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen.maker" title="Permalink to this definition">¶</a></dt>
<dd><p>A Wrapper containing various functions for generating initial conditions.
Outputs of the functions are saved to the IC object.  The IC object is 
referenced as self._parent.  So to access temperature, simply call
self._parent.T(r)</p>
<dl class="method">
<dt id="diskpy.ICgen.ICgen.maker.pos_gen">
<code class="descname">pos_gen</code><span class="sig-paren">(</span><em>method=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#maker.pos_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen.maker.pos_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>A wrapper for generating positions according to rho and sigma</p>
<p>Initializes a pos object (see pos_class.py) and saves it to ICobj.pos</p>
<dl class="docutils">
<dt>IF called with method not set, the method used is:</dt>
<dd>ICobj.settings.pos_gen.method</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.ICgen.maker.rho_gen">
<code class="descname">rho_gen</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#maker.rho_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen.maker.rho_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>A wrapper for calc_rho_zr.</p>
<p>Upon executing, generates rho and rho cdf inverse</p>
<p>Optional kwargs can be supplied and passed to the rootfinder used
(scipy.optimize.newton_krylov)</p>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.ICgen.maker.sigma_gen">
<code class="descname">sigma_gen</code><span class="sig-paren">(</span><em>r=None</em>, <em>sigma=None</em>, <em>CDF=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#maker.sigma_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen.maker.sigma_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>A Wrapper for make_sigma.sigma_gen
See make_sigma.sigma_gen for documentation</p>
<p>Upon executing, generates sigma, pdf, and cdf_inv and saves to ICobj</p>
<p>USAGE:</p>
<p># Generate sigma object from r, sigma arrays
sigma = ICobj.maker.sigma_gen(r, sigma)</p>
<p># Use pre-calculated CDF array
sigma = ICobj.maker.sigma_gen(r, sigma, CDF)</p>
<p># Generate using a profile defined in sigma_profile.py
ICobj.settings.sigma.kind = &#8216;powerlaw&#8217;
sigma = ICobj.maker.sigma_gen()</p>
<p>r and sigma should be 1-D SimArrays.  sigma is the surface density
evaluated at r</p>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.ICgen.maker.snapshot_gen">
<code class="descname">snapshot_gen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#maker.snapshot_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen.maker.snapshot_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>A wrapper for generating a tipsy snapshot from the initial conditions</p>
<p>Uses make_snapshot.py</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.ICgen.save">
<code class="descclassname">diskpy.ICgen.ICgen.</code><code class="descname">save</code><span class="sig-paren">(</span><em>ICobj</em>, <em>filename=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen.save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.ICgen_settings">
<span id="diskpy-icgen-icgen-settings-module"></span><h2>diskpy.ICgen.ICgen_settings module<a class="headerlink" href="#module-diskpy.ICgen.ICgen_settings" title="Permalink to this headline">¶</a></h2>
<p>Defines the settings class for ICgen</p>
<p>USAGE:</p>
<p>Load settings from file:</p>
<blockquote>
<div>import ICgen_settings
settings = ICgen_settings.settings(&#8216;filename&#8217;)</div></blockquote>
<p>Load settings from defaults (Defined in ICgen_settings.py):</p>
<blockquote>
<div>import ICgen_settings
settings = ICgen_settings.settings()</div></blockquote>
<p>AFTER LOADING:    
Access settings:</p>
<blockquote>
<div><p># Return number of particles:
settings.pos_gen.nParticles</p>
<p># Etc...</p>
</div></blockquote>
<p>Echo settings:</p>
<blockquote>
<div><p># Echo ALL settings
settings()</p>
<p># Echo filenames
settings.filenames()</p>
<p># Etc...</p>
</div></blockquote>
<p>READ/WRITE</p>
<p>Write (save) settings to disk:</p>
<blockquote>
<div>settings.write(&#8216;filename&#8217;)</div></blockquote>
<p>Load (read) settings from disk:</p>
<blockquote>
<div>settings.load(&#8216;filename&#8217;)</div></blockquote>
<dl class="class">
<dt id="diskpy.ICgen.ICgen_settings.changa_run">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.ICgen_settings.</code><code class="descname">changa_run</code><span class="sig-paren">(</span><em>preset='local'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_settings.html#changa_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_settings.changa_run" title="Permalink to this definition">¶</a></dt>
<dd><p>Settings for running ChaNGa (needed when calculating velocities, eps, so on)</p>
</dd></dl>

<dl class="class">
<dt id="diskpy.ICgen.ICgen_settings.filenames">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.ICgen_settings.</code><code class="descname">filenames</code><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_settings.html#filenames"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_settings.filenames" title="Permalink to this definition">¶</a></dt>
<dd><p>Filenames</p>
<dl class="docutils">
<dt>To echo settings:</dt>
<dd>filenames()</dd>
<dt>To access settings:</dt>
<dd>filenames.settingname</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="diskpy.ICgen.ICgen_settings.physical">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.ICgen_settings.</code><code class="descname">physical</code><span class="sig-paren">(</span><em>kind=None</em>, <em>binsys=None</em>, <em>starMode='single'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_settings.html#physical"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_settings.physical" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines default physical parameters</p>
<dl class="docutils">
<dt>To echo settings:</dt>
<dd>physical()</dd>
<dt>To access settings:</dt>
<dd>physical.settingname</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="diskpy.ICgen.ICgen_settings.pos_gen">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.ICgen_settings.</code><code class="descname">pos_gen</code><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_settings.html#pos_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_settings.pos_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Settings for generating random positions [STEP 2]</p>
<dl class="docutils">
<dt>To echo settings:</dt>
<dd>pos_gen()</dd>
<dt>To access settings:</dt>
<dd>pos_gen.settingname</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.ICgen_settings.print_settings">
<code class="descclassname">diskpy.ICgen.ICgen_settings.</code><code class="descname">print_settings</code><span class="sig-paren">(</span><em>setting</em>, <em>header=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_settings.html#print_settings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_settings.print_settings" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="diskpy.ICgen.ICgen_settings.rho_calc">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.ICgen_settings.</code><code class="descname">rho_calc</code><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_settings.html#rho_calc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_settings.rho_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>Settings for calculating rho(z,r)</p>
<dl class="docutils">
<dt>To echo settings:</dt>
<dd>rho_calc()</dd>
<dt>To access settings:</dt>
<dd>rho_calc.settingname</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="diskpy.ICgen.ICgen_settings.settings">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.ICgen_settings.</code><code class="descname">settings</code><span class="sig-paren">(</span><em>settings_filename=None</em>, <em>kind=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_settings.html#settings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_settings.settings" title="Permalink to this definition">¶</a></dt>
<dd><p>settings for ICgen</p>
<p>USAGE:</p>
<p>Load settings from file:</p>
<blockquote>
<div>import ICgen_settings
settings = ICgen_settings.settings(&#8216;filename&#8217;)</div></blockquote>
<p>Load settings from defaults (Defined in ICgen_settings.py):</p>
<blockquote>
<div>import ICgen_settings
settings = ICgen_settings.settings()</div></blockquote>
<p>Load settings for a given surface density profile</p>
<blockquote>
<div>import ICgen_settings
settings = ICgen_settings.settings(&#8216;powerlaw&#8217;)
or try:
settings = ICgen_settings.settings(&#8216;MQWS&#8217;)</div></blockquote>
<p>AFTER LOADING:    
Access settings:</p>
<blockquote>
<div><p># Return sigmaFileName:
settings.filenames.sigmaFileName</p>
<p># Return number of particles:
settings.pos_gen.nParticles</p>
<p># Etc...</p>
</div></blockquote>
<p>Echo settings:</p>
<blockquote>
<div><p># Echo ALL settings
settings()</p>
<p># Echo filenames
settings.filenames()</p>
<p># Etc...</p>
</div></blockquote>
<p>READ/WRITE</p>
<p>Write (save) settings to disk:</p>
<blockquote>
<div>settings.write(&#8216;filename&#8217;)</div></blockquote>
<p>Load (read) settings from disk:</p>
<blockquote>
<div>settings.load(&#8216;filename&#8217;)</div></blockquote>
<dl class="method">
<dt id="diskpy.ICgen.ICgen_settings.settings.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>settings_filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_settings.html#settings.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_settings.settings.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load settings from settings_filename.</p>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.ICgen_settings.settings.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>settings_filename=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_settings.html#settings.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_settings.settings.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save settings to settings_filename.  If settings_filename is None
(or is not set), settings_filename will be taken as the filename of
the most recent save/load</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="diskpy.ICgen.ICgen_settings.sigma">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.ICgen_settings.</code><code class="descname">sigma</code><span class="sig-paren">(</span><em>kind='powerlaw'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_settings.html#sigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_settings.sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Settings for generating a surface density profile</p>
<dl class="docutils">
<dt>To echo:</dt>
<dd>sigma()</dd>
<dt>To access settings:</dt>
<dd>sigma.settingname</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="diskpy.ICgen.ICgen_settings.snapshot">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.ICgen_settings.</code><code class="descname">snapshot</code><span class="sig-paren">(</span><em>nParticles=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_settings.html#snapshot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_settings.snapshot" title="Permalink to this definition">¶</a></dt>
<dd><p>Settings for generating tipsy files (includes particle mass, temp, and vel.)
[STEP 3]</p>
</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.ICgen_utils">
<span id="diskpy-icgen-icgen-utils-module"></span><h2>diskpy.ICgen.ICgen_utils module<a class="headerlink" href="#module-diskpy.ICgen.ICgen_utils" title="Permalink to this headline">¶</a></h2>
<p>Created on Tue Aug  5 17:37:03 2014</p>
<p>&#64;author: ibackus</p>
<dl class="function">
<dt id="diskpy.ICgen.ICgen_utils.Qeff">
<code class="descclassname">diskpy.ICgen.ICgen_utils.</code><code class="descname">Qeff</code><span class="sig-paren">(</span><em>ICobj</em>, <em>bins=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_utils.html#Qeff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_utils.Qeff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.ICgen_utils.arg_cat">
<code class="descclassname">diskpy.ICgen.ICgen_utils.</code><code class="descname">arg_cat</code><span class="sig-paren">(</span><em>arg_list</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_utils.html#arg_cat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_utils.arg_cat" title="Permalink to this definition">¶</a></dt>
<dd><p>STILL ALPHA!!!</p>
<p>arg_str = arg_cat([args1, args2, ...])</p>
<p>Concatenates a list of various command line arguments.  arg_list should
be a list containing command line argument strings.</p>
<p>Priority is given to later arguments.  So arg_list[2] overwrites arg_list[1]
if they share any flags</p>
<p><strong>EXAMPLES</strong></p>
<p>args1 = &#8216;-n 20 +cd 13 ++b fire testit&#8217;
args2 = &#8216;-n 20 +cd 300&#8217;
print arg_cat([args1, args2])</p>
<blockquote>
<div>returns:
+cd 300 -n 20 testit ++b fire</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.ICgen_utils.changa_command">
<code class="descclassname">diskpy.ICgen.ICgen_utils.</code><code class="descname">changa_command</code><span class="sig-paren">(</span><em>param_name</em>, <em>preset=None</em>, <em>changa_bin=None</em>, <em>changa_args=''</em>, <em>runner_args=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_utils.html#changa_command"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_utils.changa_command" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility for created command line commands for running ChaNGa</p>
<p><strong>ARGUMENTS</strong></p>
<dl class="docutils">
<dt>param_name <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Filename of the .param file used for ChaNGa</dd>
<dt>preset <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>if None, the default preset is used
Presets are defined in global_settings</dd>
<dt>changa_bin <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Path to the ChaNGa binary to use.  If None, defaults are used
Overrides preset binary</dd>
<dt>changa_args <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Additional user supplied arguments for ChaNGa</dd>
<dt>runner_args <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Additional user supplied arguments for the runner (ie charmrun or mpirun)</dd>
</dl>
<p><strong>RETURNS</strong></p>
<dl class="docutils">
<dt>command <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>A command line command for running ChaNGa</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.ICgen_utils.changa_run">
<code class="descclassname">diskpy.ICgen.ICgen_utils.</code><code class="descname">changa_run</code><span class="sig-paren">(</span><em>command</em>, <em>verbose=True</em>, <em>logfile_name=None</em>, <em>force_wait=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_utils.html#changa_run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_utils.changa_run" title="Permalink to this definition">¶</a></dt>
<dd><p>A wrapper for running ChaNGa</p>
<p><strong>ARGUMENTS</strong></p>
<dl class="docutils">
<dt>command <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>A full command line command for running ChaNGa.  Can be produced from 
defaults using ICgen_utils.changa_command</dd>
<dt>verbose <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>(optional) Flag for printing ChaNGa output to stdout.
If True - stdout is printed.  This will effectively makes changa_run
wait on ChaNGa completion</dd>
<dt>logfile_name <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>(optional) If set, saves ChaNGa output to file</dd>
<dt>force_wait <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>(optional) Default = False
If set, forces wait on ChaNGa before completion</dd>
</dl>
<p><strong>RETURNS</strong></p>
<dl class="docutils">
<dt>p <span class="classifier-delimiter">:</span> <span class="classifier">subprocess.Popen</span></dt>
<dd>A process object created by subprocess.Popen for the ChaNGa command</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.ICgen_utils.checkversion">
<code class="descclassname">diskpy.ICgen.ICgen_utils.</code><code class="descname">checkversion</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_utils.html#checkversion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_utils.checkversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks the version of an object.  Returns -1 if there is no version</p>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.ICgen_utils.delistify">
<code class="descclassname">diskpy.ICgen.ICgen_utils.</code><code class="descname">delistify</code><span class="sig-paren">(</span><em>in_list</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_utils.html#delistify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_utils.delistify" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverses listify.
Takes an larray object (a listified array) and returns the original array</p>
<p><strong>ARGUMENTS</strong></p>
<dl class="docutils">
<dt>in_list <span class="classifier-delimiter">:</span> <span class="classifier">larray</span></dt>
<dd>Listified array</dd>
</dl>
<p><strong>RETURNS</strong></p>
<dl class="docutils">
<dt>array <span class="classifier-delimiter">:</span> <span class="classifier">array_like or SimArray</span></dt>
<dd>array from the original data</dd>
</dl>
<p>See Also : ICgen_utils.listify</p>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.ICgen_utils.est_eps">
<code class="descclassname">diskpy.ICgen.ICgen_utils.</code><code class="descname">est_eps</code><span class="sig-paren">(</span><em>smoothlength_file</em>, <em>nstar=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_utils.html#est_eps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_utils.est_eps" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate gravitational softening length (eps) from a ChaNGa output .smoothlength
file.  eps is estimated as 1/2 the mean smoothing length</p>
<p><strong>ARGUENTS</strong></p>
<dl class="docutils">
<dt>smoothlength_file <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Filename of the .smoothlength file</dd>
<dt>nstar <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Number of star particles present</dd>
</dl>
<p><strong>RETURNS</strong></p>
<dl class="docutils">
<dt>eps <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Estimate of the gravitational softening length in simulation units</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.ICgen_utils.est_time_step">
<code class="descclassname">diskpy.ICgen.ICgen_utils.</code><code class="descname">est_time_step</code><span class="sig-paren">(</span><em>param_name</em>, <em>preset='default'</em>, <em>dDelta0=100</em>, <em>changa_args=''</em>, <em>runner_args=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_utils.html#est_time_step"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_utils.est_time_step" title="Permalink to this definition">¶</a></dt>
<dd><p>A routine to automatically estimate a reasonable time-step size for ChaNGa.
The idea is to have about half the particles fall into the lowest rung (ie 
the big time step).  This is done by calculating the rung distribution for 
a large time step by running ChaNGa and killing ChaNGa once it has output 
rung distribution.</p>
<p>NOTE: this is still fairly alpha.  A better version would probably not
just run ChaNGa and then try to kill it.  To be safe, a local ChaNGa preset
should probably be used.</p>
<p><strong>ARGUMENTS</strong></p>
<dl class="docutils">
<dt>param_name <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Filename for a ChaNGa .param file which defines parameters for the
snapshot.  The snapshot must already be saved to disk</dd>
<dt>preset <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>changa_runner preset to use.  See diskpy.global_settings</dd>
<dt>dDelta0 <span class="classifier-delimiter">:</span> <span class="classifier">int or float</span></dt>
<dd>Some large time step that should place all the particles at higher
rungs.</dd>
<dt>changa_args <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Additional command line arguments to pass to changa.  CANNOT include
-n (number of time steps) or -dt (timestep size)</dd>
<dt>runner_args <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Additional command line arguments to pass to the runner, ie to 
charmrun or mpirun</dd>
</dl>
<p><strong>RETURNS</strong></p>
<dl class="docutils">
<dt>dDelta <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>Estimated reasonable time step that places half the particles on the
lowest rung (ie the big time step)</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="diskpy.ICgen.ICgen_utils.larray">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.ICgen_utils.</code><code class="descname">larray</code><span class="sig-paren">(</span><em>shape=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_utils.html#larray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_utils.larray" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">list</span></code></p>
<p>A simple subclass of list for containing listified arrays
(see ICgen_utils.listify)
Should be instantiated by ICgen_utils.listify</p>
<p>USAGE:</p>
<p>Creating an larray object:</p>
<blockquote>
<div>a = larray() # blank larray
a = larray(shape) # sets a.shape = shape</div></blockquote>
<p>Then one can append to an larray just as with a list</p>
<blockquote>
<div>a.append(stuff)</div></blockquote>
<p>To return return a normal array:</p>
<blockquote>
<div>array = a.delistify()</div></blockquote>
<dl class="method">
<dt id="diskpy.ICgen.ICgen_utils.larray.delistify">
<code class="descname">delistify</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_utils.html#larray.delistify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_utils.larray.delistify" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array made from self.  See ICgen_utils.delistify</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.ICgen_utils.listify">
<code class="descclassname">diskpy.ICgen.ICgen_utils.</code><code class="descname">listify</code><span class="sig-paren">(</span><em>array</em>, <em>max_element=10000000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_utils.html#listify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_utils.listify" title="Permalink to this definition">¶</a></dt>
<dd><p>Breaks up an array or SimArray into chunks and saves as an larray object
(essentially, a list).  Useful for pickling very large arrays which otherwise
may throw an error with pickle</p>
<p>Whenever possible the array is NOT copied, rather a view is returned.  This
depends on the functionality of array.ravel() (see numpy.ravel)</p>
<p><strong>ARGUMENTS</strong></p>
<dl class="docutils">
<dt>array <span class="classifier-delimiter">:</span> <span class="classifier">array_like or SimArray</span></dt>
<dd>Input array to listify</dd>
<dt>max_element <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>Maximimum number of elements per chunk (i.e., per list item)</dd>
</dl>
<p><strong>RETURNS</strong></p>
<dl class="docutils">
<dt>list_array <span class="classifier-delimiter">:</span> <span class="classifier">larray</span></dt>
<dd>A listified array.</dd>
</dl>
<p>See Also : ICgen_utils.delistify</p>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.ICgen_utils.pickle_import">
<code class="descclassname">diskpy.ICgen.ICgen_utils.</code><code class="descname">pickle_import</code><span class="sig-paren">(</span><em>fname</em>, <em>moduledir=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen_utils.html#pickle_import"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.ICgen_utils.pickle_import" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a cPickle.load on fname
If an ImportError is raised, moduledir is temporarily added to sys.path
to try and find the module</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fname</strong> : filename</p>
<blockquote>
<div><p>filename of a file to open</p>
</div></blockquote>
<p><strong>moduledir</strong> : str or list of strings</p>
<blockquote class="last">
<div><p>The directory or directories to temporarily add to sys.path
IF None, a normal cPickle.load is performed</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.binary">
<span id="diskpy-icgen-binary-module"></span><h2>diskpy.ICgen.binary module<a class="headerlink" href="#module-diskpy.ICgen.binary" title="Permalink to this headline">¶</a></h2>
<p>author: &#64;dflemin3 July 2015
Module for Binary star class.  Holds the Cartesian position/velocity coordinates and Kepler orbital elements for the binary in the
reduced mass frame.  Can be initialized with orbital elements (preferred) or Cartesian position/velocity or a tipsy format snapshot
that was read in using pynbody.load(&#8220;snapshot.name&#8221;).  Just need to pass a string to let it know which input type it&#8217;s getting.</p>
<dl class="class">
<dt id="diskpy.ICgen.binary.Binary">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.binary.</code><code class="descname">Binary</code><span class="sig-paren">(</span><em>X</em>, <em>m1</em>, <em>m2</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binary.html#Binary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binary.Binary" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Defines the binary star class Binary.
Binary star class used for storing positions/velocities and Keplerian Orbital elements for the system.</p>
<p>Input Units: Lengths = AU, Velocities = km/s (<a href="#id1"><span class="problematic" id="id2">*</span></a>29.8 == VEL_UNIT), angles in degrees
Output Units: Same as input</p>
<p>Initializing:</p>
<dl class="docutils">
<dt>With Cartesian:</dt>
<dd>Binary(X,m1,m2,&#8221;Cartesian&#8221;) where X is a list or numpy array of the form [x,y,z,vx,vy,vz] and m1, m2
are the masses of the primary and secondary (M_sol), respectively</dd>
<dt>With Kepler Orbital Elements:</dt>
<dd>Binary(X,m1,m2,&#8221;Kepler&#8221;) where X is e, a, i, Omega, w, nu which are the eccentricity, semimajor axis (AU),
inclination (degrees), Longitude of Ascending Node (degrees), argument of periapsis (degrees), and
the true anomaly (degrees).  Note the units!  m1, m2 are defined above.</dd>
<dt>With Snapshot:</dt>
<dd>X is a tipsy snapshot to be loaded.  Positions and orbital elements will be calculated from it.</dd>
</dl>
<dl class="method">
<dt id="diskpy.ICgen.binary.Binary.assignOrbElems">
<code class="descname">assignOrbElems</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binary.html#Binary.assignOrbElems"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binary.Binary.assignOrbElems" title="Permalink to this definition">¶</a></dt>
<dd><p>Given array of orbital elements, set them as class parameters.  Intended as a shorthand function.</p>
<p>Input:
X is e, a, i, Omega, w, nu which are the eccentricity, semimajor axis (AU),
inclination (degrees), Longitude of Ascending Node (degrees), argument of periapsis (degrees), and
the true anomaly (degrees).  Convert all values to float for consistency and as a sanity check.</p>
<p>Output:
None</p>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.binary.Binary.computeCartesian">
<code class="descname">computeCartesian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binary.html#Binary.computeCartesian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binary.Binary.computeCartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Cartesian position and velocity in the reduced mass frame.</p>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.binary.Binary.computeOrbElems">
<code class="descname">computeOrbElems</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binary.html#Binary.computeOrbElems"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binary.Binary.computeOrbElems" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Kepler orbital elements.</p>
<p>Input: Self (must have r, v set and in proper units)</p>
<p>Output: sets and returns e,a,i,...</p>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.binary.Binary.generateICs">
<code class="descname">generateICs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binary.html#Binary.generateICs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binary.Binary.generateICs" title="Permalink to this definition">¶</a></dt>
<dd><p>From Kepler orbital elements, compute the position, velocities for two stars in ChaNGa-friendly units.
Called &#8220;generateICs&#8221; since I&#8217;ll use this mainly to...generate initial conditions</p>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.binary.Binary.reshapeData">
<code class="descname">reshapeData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binary.html#Binary.reshapeData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binary.Binary.reshapeData" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensure data, specifically r and v arrays, are of the proper shape for further manipulation.
This is useful because sometimes they come in as a list, a (1,3) numpy array or a (3,) numpy array.
Much easier to clean up upon initialization then have many checks in later functions.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.binaryUtils">
<span id="diskpy-icgen-binaryutils-module"></span><h2>diskpy.ICgen.binaryUtils module<a class="headerlink" href="#module-diskpy.ICgen.binaryUtils" title="Permalink to this headline">¶</a></h2>
<p>David Fleming
Utilities to process/interact with binary star system in ChaNGa sims</p>
<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.calcCoMVsRadius">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">calcCoMVsRadius</code><span class="sig-paren">(</span><em>s</em>, <em>rBinEdges</em>, <em>starFlag=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#calcCoMVsRadius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.calcCoMVsRadius" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the system&#8217;s center of mass as a function of radius.  At a given radius r, use the total enclosed
mass of the star(s) and gas to compute the center of mass (CoM).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>s: Tipsy-format snapshot readable by pynbody</strong></p>
<p><strong>rBinEdges: array</strong></p>
<blockquote>
<div><p>edges of the array of radii in xy plane</p>
</div></blockquote>
<p><strong>starFlag: bool</strong></p>
<blockquote>
<div><p>whether or not to consider stars in center of mass calculation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">com: array</p>
<blockquote class="last">
<div><p>Numpy array of len(r) * 3 containing location of CoM in Cartesian coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.calcDeDt">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">calcDeDt</code><span class="sig-paren">(</span><em>stars</em>, <em>tau</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#calcDeDt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.calcDeDt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the change in binary orbital eccentricity over time at each radial bin due to
the torque/mass from the surrounding CB disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>stars: pynbody stars object (sim units)</strong></p>
<p><strong>tau: torque/mass on binary due to CB disk during a given snapshot (cgs)</strong></p>
<p><strong>tau is of the form tau[radii,(x,y,z) components]</strong></p>
<p><strong>Output:</strong></p>
<p class="last"><strong>(de/dt) at each radius (unitless/second)</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.calcDiskRadialBins">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">calcDiskRadialBins</code><span class="sig-paren">(</span><em>s</em>, <em>r_in=0</em>, <em>r_out=0</em>, <em>bins=50</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#calcDiskRadialBins"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.calcDiskRadialBins" title="Permalink to this definition">¶</a></dt>
<dd><p>Cleanly partitions disk into radial bins and returns the bin edges and central bin values.  Note, default
ndim = 2 so all bins are in 2D plane (i.e. radius r is polar/cylindrical radius in xy plane which makes 
sense for thin disks)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>s: Pynbody snapshot</strong></p>
<p><strong>r_in: float</strong></p>
<blockquote>
<div><p>Inner disk radius you&#8217;ll consider (AU)</p>
</div></blockquote>
<p><strong>r_out: float</strong></p>
<blockquote>
<div><p>Outer disk radius you&#8217;ll consider (AU)</p>
</div></blockquote>
<p><strong>bins: int</strong></p>
<blockquote>
<div><p># of bins</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">r: numpy array</p>
<blockquote>
<div><p>central radial bin values (AU)</p>
</div></blockquote>
<p>rBinEdges: numpy array</p>
<blockquote class="last">
<div><p>edges of radial bins</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.calcNetTorque">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">calcNetTorque</code><span class="sig-paren">(</span><em>stars</em>, <em>gas</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#calcNetTorque"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.calcNetTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody snapshot (Tipsy format)arrays of the stars and gas of a binary surrounded by a CB disk, 
compute the net torque on the binary due to the CB disk.    
This function can be used to compute the net torque/mass due to any collection of gas (total disk, an annulus, etc) on 
the stars.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>stars, gas: pynbody-readable Tipsy snapshot arrays</strong></p>
<blockquote>
<div><p>of binary + CB disk.  Assumes units are in standard sim units (Msol,au...)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">net torque: numpy array</p>
<blockquote class="last">
<div><p>Net torque/mass vector (3D) acting on binary system in cgs.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.calcPoissonVsRadius">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">calcPoissonVsRadius</code><span class="sig-paren">(</span><em>s</em>, <em>rBinEdges</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#calcPoissonVsRadius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.calcPoissonVsRadius" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a tipsy snapshot and radial bins, compute the Poisson noise, r/sqrt(N_particles), in each radial bin.</p>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.calcQ">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">calcQ</code><span class="sig-paren">(</span><em>cs</em>, <em>kappa</em>, <em>sigma</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#calcQ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.calcQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Toomre Q parameter for a gaseous disk.  Implimented here since pynbody calculates it for a
stellar disk.
Q = (c_s * kappa)/(pi*G*Sigma) &gt; 1 -&gt; axisymmetric stability</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>c_s: float</strong></p>
<blockquote>
<div><p>sound speed (cm/s)</p>
</div></blockquote>
<p><strong>Kappa: float</strong></p>
<blockquote>
<div><p>radially epicycle frequency (1/s).  Can also be Omega for a quasi-Keplerian disk</p>
</div></blockquote>
<p><strong>Sigma: float</strong></p>
<blockquote>
<div><p>surface density at some radius (g/cm^2)</p>
</div></blockquote>
<p><strong>Output:</strong></p>
<p><strong>Q: unitless</strong></p>
<blockquote class="last">
<div><p>Toomre parameter</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.calcQVsRadius">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">calcQVsRadius</code><span class="sig-paren">(</span><em>s</em>, <em>a_in</em>, <em>a_out</em>, <em>bins</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#calcQVsRadius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.calcQVsRadius" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a tispy snapshot, compute the Toomre Q parameter at each radial point.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>s: Tipsy snapshot</strong></p>
<p><strong>a_in, a_out: floats</strong></p>
<blockquote>
<div><p>Minimum and maximum radial points on which to calculate the profile [AU]</p>
</div></blockquote>
<p><strong>bins: int</strong></p>
<blockquote>
<div><p>number of radial bins</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">r: array, AU</p>
<p class="last">Q: array, unitless</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.calcStableSigma">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">calcStableSigma</code><span class="sig-paren">(</span><em>r</em>, <em>rd</em>, <em>Mstar</em>, <em>Mdisk</em>, <em>Q</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#calcStableSigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.calcStableSigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the surfance density sigma_0 such that if the quasi-keplerian disk
had a surface density of sigma &gt; sigma_0 at an OLR, the disk would be 
unstable to a m=1 mode.  Condition comes from eqn. 110 in Shu 1990.
Note: Assumes (b_n - c)^2 ~ 1 as authors did.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>r: array</strong></p>
<blockquote>
<div><p>radii of OLR [AU]</p>
</div></blockquote>
<p><strong>rd: float</strong></p>
<blockquote>
<div><p>Maximum radially extent of the disk [AU]</p>
</div></blockquote>
<p><strong>Mstar, Mdisk: floats</strong></p>
<blockquote>
<div><p>Masses of the central star(s) and disk, respectively [Msol]</p>
</div></blockquote>
<p><strong>Q: float</strong></p>
<blockquote>
<div><p>Toomre Q stability parameter evalutated at rd</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">sigma_0: array</p>
<blockquote class="last">
<div><p>critical surfance density [Msol/AU^2]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.changaFloatSearch">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">changaFloatSearch</code><span class="sig-paren">(</span><em>name</em>, <em>simUnits=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#changaFloatSearch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.changaFloatSearch" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the name of a file containing line dumps for ChaNGa and outputs numpy arrays containing changa dumps line-by-line.</p>
<p>Genfromtxt will convert output into either an numpy array of strings or a numpy array of lists of strings.
Determine what format is, use regex library to find all floats and output accordingly.</p>
<p>Default usage is searching for linear momentum dumps of the form mg,vx,vy,vz for gas
Assume appropriate flag was used to grep data into input file</p>
<p>Input:
name: Name of input file (something.txt)
simUnits: whether or not to use simUnits (False -&gt; convert to cgs)</p>
<blockquote>
<div>Only for use for linear momentum values!</div></blockquote>
<p>Output:
Numpy array containing all floats from changa output</p>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.computeCOM">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">computeCOM</code><span class="sig-paren">(</span><em>stars</em>, <em>gas</em>, <em>cutoff=None</em>, <em>starFlag=True</em>, <em>gasFlag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#computeCOM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.computeCOM" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody star and gas arrays, compute the center of mass for the entire specified system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>stars: s.stars pynbody object</strong></p>
<p><strong>gas: s.gas pynbody object</strong></p>
<p><strong>cutoff: float</strong></p>
<blockquote>
<div><p>radius at which you only consider objects interior to it</p>
</div></blockquote>
<p><strong>starFlag: bool</strong></p>
<blockquote class="last">
<div><p>whether or not to consider stars</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.computeVelocityCOM">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">computeVelocityCOM</code><span class="sig-paren">(</span><em>s</em>, <em>cutoff=None</em>, <em>starFlag=True</em>, <em>gasFlag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#computeVelocityCOM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.computeVelocityCOM" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody star and gas arrays, compute the center of mass velocity
for the entire specified system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>s</strong> : pynbody snapshot</p>
<p><strong>cutoff</strong> : float</p>
<blockquote>
<div><p>radius at which you only consider objects interior to it [AU]</p>
</div></blockquote>
<p><strong>starFlag</strong> : bool</p>
<blockquote>
<div><p>whether or not to consider stars</p>
</div></blockquote>
<p><strong>gasFlag</strong> : bool</p>
<blockquote>
<div><p>whether or not to consider gas</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Center of mass velocity: SimArry</p>
<blockquote>
<div><p>in AU for each vx,vy,vz component</p>
</div></blockquote>
<p>Note: a lot of &#8220;strip_units&#8221; commands included to prevent throwing weird value errors.  As long as all masses</p>
<p class="last">are in solar masses and positions in AU before this is run, you won&#8217;t have any problems.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.diskAverage">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">diskAverage</code><span class="sig-paren">(</span><em>s</em>, <em>r_out</em>, <em>bins=50</em>, <em>avgFlag=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#diskAverage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.diskAverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the accretion disk mass-averaged for x via the following equation:
integral of 2*pisigma*x*r*dr / integral of 2*pi*sigma*r*dr.
Sigma, e,a... calculated on the fly to ensure that they are all evaluated at
the same location.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>s</strong> : tipsy snapshot</p>
<p><strong>r_out</strong> : float</p>
<blockquote>
<div><p>outer radii for averaging region. If none, use entire disk</p>
</div></blockquote>
<p><strong>bins</strong> : int</p>
<blockquote>
<div><p>how many radial bins to calculate quantities over</p>
</div></blockquote>
<p><strong>avgFlag</strong> : bool</p>
<blockquote>
<div><p>whether or not to average over all particles in a radial bin
for orbital element calculation</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">y: list</p>
<blockquote class="last">
<div><p>disk-averaged Keplerian orbital elements [e,a,i,Omega,w,nu] in AU, degrees (depending on unit)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.diskPrecession">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">diskPrecession</code><span class="sig-paren">(</span><em>s</em>, <em>radius</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#diskPrecession"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.diskPrecession" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the precession of the disk due to the binary quadrupole moment.
The precessions considered are kappa_r and kappa_z corresponding to the
precession of the argument of periapsis and longitude of th ascending node,
respectively.</p>
<p>Precssion frequency: Omega_p = Omega - Kappa
Omega = sqrt((G*mu/r^3)*(1 + 3*alpha/r^2)) == orbital frequency</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>s: Tipsy snapshot</strong></p>
<p><strong>r: numpy array</strong></p>
<blockquote>
<div><p>array of radial bins centers [AU]</p>
</div></blockquote>
<p><strong>Returns:</strong></p>
<p><strong>&#8212;&#8212;-</strong></p>
<p><strong>Kappa array: numpy array</strong></p>
<blockquote class="last">
<div><p>2 x len(rBinEdges)-1 array containing precession at each radial point in 1/s</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.estimateCBResonances">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">estimateCBResonances</code><span class="sig-paren">(</span><em>s</em>, <em>r_max</em>, <em>m_max=5</em>, <em>l_max=5</em>, <em>bins=2500</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#estimateCBResonances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.estimateCBResonances" title="Permalink to this definition">¶</a></dt>
<dd><p>Given pynbody snapshot star and gas SimArrays, computes the resonances of disk on binary as a function of period.
Disk radius, in au, is convered to angular frequency which will then be used to compute corotation and inner/outer Lindblad resonances.
Assumption: Assumes m_disk &lt;&lt; m_bin which holds in general for simulations considered
For reference: Kappa, omega computed in ~ 1/day intermediate units.
Uses approximations from Artymowicz 1994</p>
<p>Inputs:
stars,gas: Pynbody snapshot .star and .gas SimArrays (in au, Msol, etc)
r_max: maximum disk radius for calculations (au)
bins: number of radial bins to calculate over</p>
<p>Output:
Orbital frequency for corotation and inner/outer resonances as float and 2 arrays</p>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.findCBResonances">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">findCBResonances</code><span class="sig-paren">(</span><em>s</em>, <em>r</em>, <em>r_min</em>, <em>r_max</em>, <em>m_max=4</em>, <em>l_max=4</em>, <em>bins=50</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#findCBResonances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.findCBResonances" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Given Tipsy snapshot, computes the resonances of disk on binary as a function of orbital angular frequency omega.
Disk radius, in au, is convered to angular frequency which will then be used to compute corotation 
and inner/outer Lindblad resonances.</div></blockquote>
<p>Note: r given MUST correspond to r over which de/dt was calculated.  Otherwise, scale gets all messed up</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>s: Tipsy-format snapshot</strong></p>
<blockquote>
<div><dl class="docutils">
<dt>r: array</dt>
<dd><p class="first last">radius array over which de/dt was calculated</p>
</dd>
<dt>r_min,r_max: floats</dt>
<dd><p class="first last">min/maximum disk radius for calculations (au)</p>
</dd>
<dt>bins: int</dt>
<dd><p class="first last">number of radial bins to calculate over</p>
</dd>
<dt>m_max,l_max: ints</dt>
<dd><p class="first last">maximum orders of (m,l) LR</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Orbital frequency: numpy array</p>
<blockquote class="last">
<div><p>for corotation and inner/outer resonances and radii as float and numpy arrays</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.find_crit_radius">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">find_crit_radius</code><span class="sig-paren">(</span><em>r</em>, <em>array</em>, <em>toFind</em>, <em>num=1000</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#find_crit_radius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.find_crit_radius" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array as a function of radius,     the array value to search for, the radial range to search over and the search
resolution, find the corresponding radius.
Assumed that array is calculated as a function of r.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>r: array</strong></p>
<blockquote>
<div><p>array of radial points</p>
</div></blockquote>
<p><strong>array: array</strong></p>
<blockquote>
<div><p>array of quantity of interest (could be surface density?) as a function of r</p>
</div></blockquote>
<p><strong>toFind: float</strong></p>
<blockquote>
<div><p>array value you&#8217;re looking for</p>
</div></blockquote>
<p><strong>num: int</strong></p>
<blockquote>
<div><p>resolution of search</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">critial_radius: float</p>
<blockquote class="last">
<div><p>radius at which array(critical_radius) = toFind (approximately)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.linearMomentumEffects">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">linearMomentumEffects</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em>, <em>v1</em>, <em>v2</em>, <em>m1</em>, <em>m2</em>, <em>accretion</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#linearMomentumEffects"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.linearMomentumEffects" title="Permalink to this definition">¶</a></dt>
<dd><p>Given initial binary system parameters and an array tracking the accretion events, calculate the effects of accretion
on the semimajor axis and eccentricity of the binary system.</p>
<p>Inputs: Assume all input arrays are in simulation units
Masses of primary and secondary (m1, m2 in Msol)
Position arrays of primary and secondary x1, x2 (in AU)
Velocity arrays of primary and secondary v1, v2 (in km/s)
Numpy array of accretion events of the form [m vx vy vz ...] for each accreted gas particle at time of accretion</p>
<p>Output:
Semimajor axis, eccentricity of binary system after accretion events</p>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.orbElemsVsRadius">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">orbElemsVsRadius</code><span class="sig-paren">(</span><em>s</em>, <em>rBinEdges</em>, <em>average=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#orbElemsVsRadius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.orbElemsVsRadius" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the orbital elements for disk particles about a binary system in given radial bins.
Assumes center of mass has v ~ 0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>s: Tipsy snapshot</strong></p>
<p><strong>rBinEdges: numpy array</strong></p>
<blockquote>
<div><p>Radial bin edges [AU] preferably calculated using binaryUtils.calcDiskRadialBins</p>
</div></blockquote>
<p><strong>average: bool</strong></p>
<blockquote>
<div><p>True -&gt; average over all particles in bin, false -&gt; randomly select 1 particle in bin</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">orbElems: numpy array</p>
<blockquote class="last">
<div><p>6 x len(rBinEdges) - 1 containing orbital elements at each radial bin
as e, a, i, Omega, w, nu</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.binaryUtils.torqueVsRadius">
<code class="descclassname">diskpy.ICgen.binaryUtils.</code><code class="descname">torqueVsRadius</code><span class="sig-paren">(</span><em>s</em>, <em>rBinEdges</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/binaryUtils.html#torqueVsRadius"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.binaryUtils.torqueVsRadius" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes in pynbody snapshot s for a binary system with a CB disk 
returns torque per unit mass vs radius and the approximate radius of the bin where
that torque was calculated.  Note, I only care about the z component of the torque
since this is a circumbinary disk system 
Note: This function is best for returning proper disk radial bins.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>s: pynbody snapshot of binary + CB disk</strong></p>
<p><strong>Bins: int</strong></p>
<blockquote>
<div><p>number of radial bins to make the calculation</p>
</div></blockquote>
<p><strong>r_in, r_out: floats</strong></p>
<blockquote>
<div><p>Inner and outer radii over which torque is calculated (au)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">tau: numpy array</p>
<blockquote class="last">
<div><p>Torque per unit mass as function of radius (cgs vs au)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.calc_temp">
<span id="diskpy-icgen-calc-temp-module"></span><h2>diskpy.ICgen.calc_temp module<a class="headerlink" href="#module-diskpy.ICgen.calc_temp" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Calculates the temperature at a given r for a power law:</dt>
<dd>T = T0(r/r0)^Tpower</dd>
</dl>
<p>If r_in has no units, au are assumed</p>
<p>Created on Wed Jan 29 13:20:04 2014</p>
<p>&#64;author: ibackus</p>
<dl class="class">
<dt id="diskpy.ICgen.calc_temp.T">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.calc_temp.</code><code class="descname">T</code><span class="sig-paren">(</span><em>ICobj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/calc_temp.html#T"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.calc_temp.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates temperature as a function of radius.  Updating the settings 
contained in the ICobject will automatically cause T to be calculated
accordingly.  ICobject should contain the attribute &#8216;settings&#8217;.  Settings
for temperature are contained in settings.physical</p>
<p>USAGE:</p>
<p>T = calc_temp.T(ICobject)       # Generate function to calculate T</p>
<p>T(r)        # Calculate T at r</p>
<p>There are multiple kinds of available temperature profiles.  They are set
in ICobject.settings.physical.kind.  They are:</p>
<dl class="docutils">
<dt>&#8216;powerlaw&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">(default)</span></dt>
<dd><p class="first">Follows a power law, T = T0 * (r/r0)**Tpower
Settings needed:</p>
<blockquote class="last">
<div>T0
r0
Tpower
Tmin (optional)
Tmax (optional)</div></blockquote>
</dd>
<dt>&#8216;MQWS&#8217;</dt>
<dd><dl class="first last docutils">
<dt>Mimics Mayer, Quinn et. all 2004 ICs.  Settings needed:</dt>
<dd>T0
r0 (same as r_in in the paper)
Tmin
Tmax (optional)</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="diskpy.ICgen.calc_temp.T.T_adiabatic">
<code class="descname">T_adiabatic</code><span class="sig-paren">(</span><em>r</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/calc_temp.html#T.T_adiabatic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.calc_temp.T.T_adiabatic" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the adiabatic temperature profile as a function of r</p>
<p>setup_interior must be run first</p>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.calc_temp.T.T_nocut">
<code class="descname">T_nocut</code><span class="sig-paren">(</span><em>r</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/calc_temp.html#T.T_nocut"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.calc_temp.T.T_nocut" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the temperature as a function of r ignoring any interior
cutoff.  The interior cutoff would affect T for adiabatic disks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>T</strong> : SimArray</p>
<blockquote class="last">
<div><p>temperature</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.calc_temp.T.setup_interior">
<code class="descname">setup_interior</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/calc_temp.html#T.setup_interior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.calc_temp.T.setup_interior" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the interior temperature profile.</p>
<p>For an adiabatic disk, this is an adiabatic profile inside of the
cutoff.  Otherwise, nothing is done.</p>
<p>Requires that sigma already be calculated</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.calc_velocity">
<span id="diskpy-icgen-calc-velocity-module"></span><h2>diskpy.ICgen.calc_velocity module<a class="headerlink" href="#module-diskpy.ICgen.calc_velocity" title="Permalink to this headline">¶</a></h2>
<p>Created on Wed Apr  9 15:39:28 2014</p>
<p>&#64;author: ibackus</p>
<dl class="function">
<dt id="diskpy.ICgen.calc_velocity.v_xy">
<code class="descclassname">diskpy.ICgen.calc_velocity.</code><code class="descname">v_xy</code><span class="sig-paren">(</span><em>f</em>, <em>param</em>, <em>changbin=None</em>, <em>nr=50</em>, <em>min_per_bin=100</em>, <em>changa_preset=None</em>, <em>max_particles=None</em>, <em>est_eps=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/calc_velocity.html#v_xy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.calc_velocity.v_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to calculate the circular velocities for particles in a thin
(not flat) keplerian disk.  Also estimates gravitational softening (eps)
for the gas particles</p>
<p>Requires ChaNGa</p>
<p>Note that this will change the velocities IN f</p>
<p><strong>ARGUMENTS</strong></p>
<dl class="docutils">
<dt>f <span class="classifier-delimiter">:</span> <span class="classifier">tipsy snapshot</span></dt>
<dd>For a gaseous disk</dd>
<dt>param <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>a dictionary containing params for changa. (see configparser)</dd>
<dt>changbin <span class="classifier-delimiter">:</span> <span class="classifier">str  (OPTIONAL)  </span></dt>
<dd>If set, should be the full path to the ChaNGa executable.  If None, 
an attempt to find ChaNGa is made</dd>
<dt>nr <span class="classifier-delimiter">:</span> <span class="classifier">int (optional)</span></dt>
<dd>number of radial bins to use when averaging over accelerations</dd>
<dt>min_per_bin <span class="classifier-delimiter">:</span> <span class="classifier">int (optional)</span></dt>
<dd>The minimum number of particles to be in each bin.  If there are too
few particles in a bin, it is merged with an adjacent bin.  Thus,
actual number of radial bins may be less than nr.</dd>
<dt>changa_preset <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>Which ChaNGa execution preset to use (ie &#8216;mpi&#8217;, &#8216;local&#8217;, ...).  See
ICgen_utils.changa_command</dd>
<dt>max_particles <span class="classifier-delimiter">:</span> <span class="classifier">int or None</span></dt>
<dd>Specifies the maximum number of particles to use for calculating
accelerations and velocities.  Setting a smaller number can speed up
computation and save on memory but can yield noisier results.
If None, max is unlimited.</dd>
<dt>est_eps <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Estimate eps (gravitational softening length).  Default is True.
If False, it is assumed eps has already been estimated</dd>
</dl>
<p><strong>RETURNS</strong></p>
<p>Nothing.  Velocities are updated within f as is eps</p>
</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.kepler38">
<span id="diskpy-icgen-kepler38-module"></span><h2>diskpy.ICgen.kepler38 module<a class="headerlink" href="#module-diskpy.ICgen.kepler38" title="Permalink to this headline">¶</a></h2>
<p>&#64;author: dflemin3
Script for generating disk ICs about a stellar system
using ibackus&#8217;s ICgen routines.
See <a class="reference external" href="https://github.com/ibackus/ICgen">https://github.com/ibackus/ICgen</a></p>
</div>
<div class="section" id="module-diskpy.ICgen.make_sigma">
<span id="diskpy-icgen-make-sigma-module"></span><h2>diskpy.ICgen.make_sigma module<a class="headerlink" href="#module-diskpy.ICgen.make_sigma" title="Permalink to this headline">¶</a></h2>
<p>Calculates cubic spline interpolations for sigma(r) and probability(r)
probability = 2*pi*r*sigma</p>
<p>Created on Mon Jan 27 13:00:52 2014</p>
<p>&#64;author: ibackus</p>
<dl class="class">
<dt id="diskpy.ICgen.make_sigma.sigma_gen">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.make_sigma.</code><code class="descname">sigma_gen</code><span class="sig-paren">(</span><em>r_bins</em>, <em>sigmaBinned</em>, <em>CDF=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/make_sigma.html#sigma_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.make_sigma.sigma_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to generate the surface density (sigma), probability density (pdf)
and inverse cumulative distribution function (cdf_inv) as a function of r</p>
<p>USAGE:</p>
<p># Generate sigma (settings is generated by ICgen_settings.py, see below)</p>
<p>import make_sigma
sigma = make_sigma.sigma_gen(r, sigma)</p>
<p># Calculate at various r positions:</p>
<p>sigma(r)    # returns sigma evaluated at r
sigma.sigma(r)  # returns sigma evaluated at r
pdf = sigma.pdf(r)  # returns pdf evaluated at r
cdf_inv = sigma.cdf_inv(m) # returns cdv_inv at m for 0 &lt; m &lt; 1</p>
<p># Generate sigma with a precalulated CDF (as done before)</p>
<p>sigma = make_sigma.sigma_gen(r, sigma, CDF)</p>
<dl class="method">
<dt id="diskpy.ICgen.make_sigma.sigma_gen.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/make_sigma.html#sigma_gen.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.make_sigma.sigma_gen.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the sigma object</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.make_snapshot">
<span id="diskpy-icgen-make-snapshot-module"></span><h2>diskpy.ICgen.make_snapshot module<a class="headerlink" href="#module-diskpy.ICgen.make_snapshot" title="Permalink to this headline">¶</a></h2>
<p>Created on Fri Mar 21 15:11:31 2014</p>
<p>&#64;author: ibackus</p>
<dl class="function">
<dt id="diskpy.ICgen.make_snapshot.snapshot_gen">
<code class="descclassname">diskpy.ICgen.make_snapshot.</code><code class="descname">snapshot_gen</code><span class="sig-paren">(</span><em>ICobj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/make_snapshot.html#snapshot_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.make_snapshot.snapshot_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a tipsy snapshot from the initial conditions object ICobj.</p>
<p>Returns snapshot, param</p>
<blockquote>
<div>snapshot: tipsy snapshot
param: dictionary containing info for a .param file</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.make_snapshotBinary">
<span id="diskpy-icgen-make-snapshotbinary-module"></span><h2>diskpy.ICgen.make_snapshotBinary module<a class="headerlink" href="#module-diskpy.ICgen.make_snapshotBinary" title="Permalink to this headline">¶</a></h2>
<p>Created on Fri Mar 21 15:11:31 2014</p>
<p>&#64;author: ibackus
&#64;editor: dfleming
-Note: indentation is 4 spaces in this file, not a tab!</p>
<dl class="function">
<dt id="diskpy.ICgen.make_snapshotBinary.snapshot_gen">
<code class="descclassname">diskpy.ICgen.make_snapshotBinary.</code><code class="descname">snapshot_gen</code><span class="sig-paren">(</span><em>ICobj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/make_snapshotBinary.html#snapshot_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.make_snapshotBinary.snapshot_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a tipsy snapshot from the initial conditions object ICobj.</p>
<p>Returns snapshot, param</p>
<blockquote>
<div>snapshot: tipsy snapshot
param: dictionary containing info for a .param file</div></blockquote>
<p>Note: Code has been edited (dflemin3) such that now it returns a snapshot for a circumbinary disk
where initial conditions generated assuming star at origin of mass M.  After gas initialized, replaced
star at origin with binary system who&#8217;s center of mass lies at the origin and who&#8217;s mass m1 +m2 = M</p>
</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.make_snapshotSType">
<span id="diskpy-icgen-make-snapshotstype-module"></span><h2>diskpy.ICgen.make_snapshotSType module<a class="headerlink" href="#module-diskpy.ICgen.make_snapshotSType" title="Permalink to this headline">¶</a></h2>
<p>Created on Fri Mar 21 15:11:31 2014</p>
<p>&#64;author: ibackus
&#64;editor: dflemin3
-Note: indentation is 4 spaces in this file, not a tab!</p>
<p>This module initializes an S-type binary system in which the gas disk is around
the primary, not both stars!  Assumes a_bin &gt;&gt; r_disk such that the disk&#8217;s
velocity is dominated by the influence of the primary.</p>
<dl class="function">
<dt id="diskpy.ICgen.make_snapshotSType.snapshot_gen">
<code class="descclassname">diskpy.ICgen.make_snapshotSType.</code><code class="descname">snapshot_gen</code><span class="sig-paren">(</span><em>ICobj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/make_snapshotSType.html#snapshot_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.make_snapshotSType.snapshot_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a tipsy snapshot from the initial conditions object ICobj.</p>
<p>Returns snapshot, param</p>
<blockquote>
<div>snapshot: tipsy snapshot
param: dictionary containing info for a .param file</div></blockquote>
<p>Note: Code has been edited (dflemin3) such that now it returns a snapshot for a circumbinary disk
where initial conditions generated assuming star at origin of mass M.  After gas initialized, replaced
star at origin with binary system who&#8217;s center of mass lies at the origin and who&#8217;s mass m1 +m2 = M</p>
</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.make_snapshotSTypeSupplied">
<span id="diskpy-icgen-make-snapshotstypesupplied-module"></span><h2>diskpy.ICgen.make_snapshotSTypeSupplied module<a class="headerlink" href="#module-diskpy.ICgen.make_snapshotSTypeSupplied" title="Permalink to this headline">¶</a></h2>
<p>Created on Fri Mar 21 15:11:31 2014</p>
<p>&#64;author: ibackus
&#64;editor: dflemin3
-Note: indentation is 4 spaces in this file, not a tab!</p>
<p>This module initializes an S-type binary system in which the gas disk is around
the primary, not both stars!  Assumes a_bin &gt;&gt; r_disk such that the disk&#8217;s
velocity is dominated by the influence of the primary.</p>
<dl class="function">
<dt id="diskpy.ICgen.make_snapshotSTypeSupplied.snapshot_gen">
<code class="descclassname">diskpy.ICgen.make_snapshotSTypeSupplied.</code><code class="descname">snapshot_gen</code><span class="sig-paren">(</span><em>ICobj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/make_snapshotSTypeSupplied.html#snapshot_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.make_snapshotSTypeSupplied.snapshot_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a tipsy snapshot from the initial conditions object ICobj.</p>
<p>Returns snapshot, param</p>
<blockquote>
<div>snapshot: tipsy snapshot
param: dictionary containing info for a .param file</div></blockquote>
<p>Note: Code has been edited (dflemin3) such that now it returns a snapshot for a circumbinary disk
where initial conditions generated assuming star at origin of mass M.  After gas initialized, replaced
star at origin with binary system who&#8217;s center of mass lies at the origin and who&#8217;s mass m1 +m2 = M</p>
</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.pos_class">
<span id="diskpy-icgen-pos-class-module"></span><h2>diskpy.ICgen.pos_class module<a class="headerlink" href="#module-diskpy.ICgen.pos_class" title="Permalink to this headline">¶</a></h2>
<p>Defines a function to randomly generate particle positions according to 
the desired surface density profile (sigma vs r) and the vertical profile
(rho vs r,z).</p>
<p>Created on Mon Jan 27 18:48:04 2014</p>
<p>&#64;author: ibackus</p>
<dl class="class">
<dt id="diskpy.ICgen.pos_class.pos">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.pos_class.</code><code class="descname">pos</code><span class="sig-paren">(</span><em>ICobj</em>, <em>method=None</em>, <em>generate=True</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/pos_class.html#pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.pos_class.pos" title="Permalink to this definition">¶</a></dt>
<dd><p>position class.  Generates particle positions from rho and sigma</p>
<p>USAGE:
# method = &#8216;grid&#8217; or &#8216;random&#8217;    
pos = pos_class.pos(ICobj, method)</p>
<p>ICobj should be an initial conditions object (ICgen.IC) with rho already
calculated.</p>
</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.rhosolver">
<span id="diskpy-icgen-rhosolver-module"></span><h2>diskpy.ICgen.rhosolver module<a class="headerlink" href="#module-diskpy.ICgen.rhosolver" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Aug  3 16:28:37 2015</p>
<p>&#64;author: ibackus</p>
<dl class="function">
<dt id="diskpy.ICgen.rhosolver.calc_rho">
<code class="descclassname">diskpy.ICgen.rhosolver.</code><code class="descname">calc_rho</code><span class="sig-paren">(</span><em>IC</em>, <em>r=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/rhosolver.html#calc_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.rhosolver.calc_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the density for the initial conditions object IC by numerically
solving hydrostatic equilibrium (see vertical_solver)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>IC</strong> : IC object</p>
<blockquote>
<div><p>Initial conditions object</p>
</div></blockquote>
<p><strong>r</strong> : SimArray</p>
<blockquote>
<div><p>(optional) intial bin radii: not all will be used</p>
</div></blockquote>
<p><strong>**kwargs</strong> : keyword arguments to pass to the root finder used</p>
<blockquote>
<div><p>(scipy.optimize.newton_krylov)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R</strong> : 1D SimArray</p>
<blockquote>
<div><p>Radial bins the density is calculated at</p>
</div></blockquote>
<p><strong>z</strong> : 2D SimArray</p>
<blockquote>
<div><p>z points the density is calculated at.  z[i,j] is the ith z position
at R[j]</p>
</div></blockquote>
<p><strong>rho</strong> : 2D SimArray</p>
<blockquote class="last">
<div><p>Density as a function of (z,R).  rho[i,j] is calculated at 
(z[i,j], R[j])</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.rhosolver.cdf_inv">
<code class="descclassname">diskpy.ICgen.rhosolver.</code><code class="descname">cdf_inv</code><span class="sig-paren">(</span><em>z</em>, <em>r</em>, <em>rho</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/rhosolver.html#cdf_inv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.rhosolver.cdf_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse CDF as a function of r over the whole disk</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z</strong> : SimArray or array</p>
<blockquote>
<div><p>2D z-positions that rho is calculated at.  z[i,j] is the ith z bin
at r[j]</p>
</div></blockquote>
<p><strong>r</strong> : SimArray or array</p>
<blockquote>
<div><p>Radial bins (1D array) the z and rho are calculated at</p>
</div></blockquote>
<p><strong>rho</strong> : SimArray or array</p>
<blockquote>
<div><p>2D array of density values.  rho[i,j] is rho at z[i,j], r[j]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f</strong> : function</p>
<blockquote class="last">
<div><p>Inverse CDF.  f(m, r) = z returns the z value for radius and 0&lt;m&lt;1.
r and m are 1-D arrays of the same length, or numbers.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.rhosolver.cdf_inv_z">
<code class="descclassname">diskpy.ICgen.rhosolver.</code><code class="descname">cdf_inv_z</code><span class="sig-paren">(</span><em>z</em>, <em>rho</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/rhosolver.html#cdf_inv_z"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.rhosolver.cdf_inv_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse of the cumulative distribution function for
probability as a function of z for a given r (ie gives you z as a function
of the CDF)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z</strong> : array or SimArray</p>
<blockquote>
<div><p>Positions to calculate over.  1D array</p>
</div></blockquote>
<p><strong>rho: array or SimArray</strong></p>
<blockquote>
<div><p>Density as a function of z.  Treated as an un-normalized PDF. 1D array</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>f</strong> : array</p>
<blockquote>
<div><p>Normalized CDF</p>
</div></blockquote>
<p><strong>z</strong> : array or SimArray</p>
<blockquote class="last">
<div><p>z as a functin of the normalized CDF.  Monotonically increasing</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>To ensure z, f are montonically increasing, some values are dropped.
The remaining values of f are padded with 2, and the values of z are
padded with z.max()</p>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.rhosolver.loadrho">
<code class="descclassname">diskpy.ICgen.rhosolver.</code><code class="descname">loadrho</code><span class="sig-paren">(</span><em>IC</em>, <em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/rhosolver.html#loadrho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.rhosolver.loadrho" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a rhosolver object from f (a file or dictionary) and saves it to
IC.rho</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f</strong> : dict or str</p>
<blockquote>
<div><p>Either a dictionary containing everything required to load rho
or a filename pointing to a pickled dictionary</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rho</strong> : rhosolver</p>
<blockquote class="last">
<div><p>An intialied rho solver object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.rhosolver.rhointerp">
<code class="descclassname">diskpy.ICgen.rhosolver.</code><code class="descname">rhointerp</code><span class="sig-paren">(</span><em>z</em>, <em>r</em>, <em>rho</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/rhosolver.html#rhointerp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.rhosolver.rhointerp" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a callable interpolation of rho on the z, r points</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z</strong> : 2D SimArray or array</p>
<blockquote>
<div><p>z[i,j] is the ith z value at r[j]</p>
</div></blockquote>
<p><strong>r</strong> : 1D SimArray or array</p>
<blockquote>
<div><p>Radial positions</p>
</div></blockquote>
<p><strong>rho</strong> : SimArray</p>
<blockquote>
<div><p>density at points z[i,j], r[j]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rhospline</strong> : function</p>
<blockquote class="last">
<div><p>An interpolation function for estimating rho as a function of z, r</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="diskpy.ICgen.rhosolver.rhosolver">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.rhosolver.</code><code class="descname">rhosolver</code><span class="sig-paren">(</span><em>IC</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/rhosolver.html#rhosolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.rhosolver.rhosolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the rho class that allows the solving of vertical hydrostatic 
equilibrium over the disk, and generates callable methods for estimating
density and the normalized inverse CDF over the disk.</p>
<p class="rubric">Examples</p>
<p>Initialize rho, solve vertical equilibrium</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IC</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">sigma_gen</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">rhosolver</span><span class="p">(</span><span class="n">IC</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>Rho is now callable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">.</span><span class="n">cdf_inv</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>Save rho</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rho_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;z&#39;</span><span class="p">:</span> <span class="n">rho</span><span class="o">.</span><span class="n">z_bins</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">:</span> <span class="n">rho</span><span class="o">.</span><span class="n">r_bins</span><span class="p">,</span> <span class="s">&#39;rho&#39;</span><span class="p">:</span> <span class="n">rho</span><span class="o">.</span><span class="n">rho_binned</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">rho_dict</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;rhofile.p&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Load rho</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;rhofile.p&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="diskpy.ICgen.rhosolver.rhosolver.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/rhosolver.html#rhosolver.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.rhosolver.rhosolver.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load/initialize from a dictionary or a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f</strong> : dict or str</p>
<blockquote class="last">
<div><p>Either a dictionary containing everything required to load rho
or a filename pointing to a pickled dictionary</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.rhosolver.rhosolver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/rhosolver.html#rhosolver.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.rhosolver.rhosolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the hydrostatic vertical equilibrium for the disk to find the
density.  Also calculates the normalized inverse CDF</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kwargs :</strong></p>
<blockquote class="last">
<div><p>(optional) key word arguments to pass to the root finder
[scipy.optimize.newton_krylov]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.rhosolver.setup_r_bins">
<code class="descclassname">diskpy.ICgen.rhosolver.</code><code class="descname">setup_r_bins</code><span class="sig-paren">(</span><em>IC</em>, <em>r=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/rhosolver.html#setup_r_bins"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.rhosolver.setup_r_bins" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.sigma_profile">
<span id="diskpy-icgen-sigma-profile-module"></span><h2>diskpy.ICgen.sigma_profile module<a class="headerlink" href="#module-diskpy.ICgen.sigma_profile" title="Permalink to this headline">¶</a></h2>
<p>Created on Mon Jun 23 10:17:53 2014</p>
<p>&#64;author: ibackus</p>
<dl class="function">
<dt id="diskpy.ICgen.sigma_profile.MQWS">
<code class="descclassname">diskpy.ICgen.sigma_profile.</code><code class="descname">MQWS</code><span class="sig-paren">(</span><em>settings</em>, <em>T</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/sigma_profile.html#MQWS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.sigma_profile.MQWS" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a surface density profile as the per method used in Mayer, Quinn,
Wadsley, and Stadel 2004</p>
<p>** ARGUMENTS **
NOTE: if units are not supplied, assumed units are AU, Msol</p>
<dl class="docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">IC settings</span></dt>
<dd>settings like those contained in an IC object (see ICgen_settings.py)</dd>
<dt>T <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd>A function to calculate temperature as a function of radius</dd>
</dl>
<p>** RETURNS **</p>
<dl class="docutils">
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">SimArray</span></dt>
<dd>Radii at which sigma is calculated</dd>
<dt>sigma <span class="classifier-delimiter">:</span> <span class="classifier">SimArray</span></dt>
<dd>Surface density profile as a function of R</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.sigma_profile.make_profile">
<code class="descclassname">diskpy.ICgen.sigma_profile.</code><code class="descname">make_profile</code><span class="sig-paren">(</span><em>ICobj</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/sigma_profile.html#make_profile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.sigma_profile.make_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>A wrapper for generating surface density profiles according to the IC object.</p>
<p>Settings for the profile are defined in ICobj.settings.  Which profile gets
used is defined by ICobj.settings.sigma.kind</p>
<p>Currently available kinds are:</p>
<p>viscous
powerlaw
MQWS</p>
<p><strong>RETURNS</strong></p>
<dl class="docutils">
<dt>r <span class="classifier-delimiter">:</span> <span class="classifier">SimArray</span></dt>
<dd>Radii at which sigma is calculated</dd>
<dt>sigma <span class="classifier-delimiter">:</span> <span class="classifier">SimArray</span></dt>
<dd>Surface density profile as a function of R</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.sigma_profile.powerlaw">
<code class="descclassname">diskpy.ICgen.sigma_profile.</code><code class="descname">powerlaw</code><span class="sig-paren">(</span><em>settings</em>, <em>T=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/sigma_profile.html#powerlaw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.sigma_profile.powerlaw" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a surface density profile according to a powerlaw sigma ~ 1/r
with a smooth interior cutoff and smooth exterior exponential cutoff.</p>
<p><strong>ARGUMENTS</strong></p>
<dl class="docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">IC settings</span></dt>
<dd>settings like those contained in an IC object (see ICgen_settings.py)</dd>
<dt>T <span class="classifier-delimiter">:</span> <span class="classifier">callable function</span></dt>
<dd>Function that returns temperature of the disk as a function of radius
IF none, a powerlaw temperature is assumed</dd>
</dl>
<p><strong>RETURNS</strong></p>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">SimArray</span></dt>
<dd>Radii at which sigma is calculated</dd>
<dt>sigma <span class="classifier-delimiter">:</span> <span class="classifier">SimArray</span></dt>
<dd>Surface density profile as a function of R</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.sigma_profile.viscous">
<code class="descclassname">diskpy.ICgen.sigma_profile.</code><code class="descname">viscous</code><span class="sig-paren">(</span><em>settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/sigma_profile.html#viscous"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.sigma_profile.viscous" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a surface density profile derived from a self-similarity solution
for a viscous disk, according to:</p>
<blockquote>
<div>sigma ~ r^-gamma exp(-r^(2-gamma))</div></blockquote>
<p>Where r is a dimensionless radius and gamma is a constant less than 2.
Rd (disk radius) is defined as the radius containing 95% of the disk mass</p>
<p><strong>ARGUMENTS</strong></p>
<dl class="docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">IC settings</span></dt>
<dd>settings like those contained in an IC object (see ICgen_settings.py)</dd>
</dl>
<p><strong>RETURNS</strong></p>
<dl class="docutils">
<dt>R <span class="classifier-delimiter">:</span> <span class="classifier">SimArray</span></dt>
<dd>Radii at which sigma is calculated</dd>
<dt>sigma <span class="classifier-delimiter">:</span> <span class="classifier">SimArray</span></dt>
<dd>Surface density profile as a function of R</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen.test">
<span id="diskpy-icgen-test-module"></span><h2>diskpy.ICgen.test module<a class="headerlink" href="#module-diskpy.ICgen.test" title="Permalink to this headline">¶</a></h2>
<p>&#64;author: dflemin3
Script for generating disk ICs about a stellar system
using ibackus&#8217;s ICgen routines.
See <a class="reference external" href="https://github.com/ibackus/ICgen">https://github.com/ibackus/ICgen</a></p>
</div>
<div class="section" id="module-diskpy.ICgen.vertical_solver">
<span id="diskpy-icgen-vertical-solver-module"></span><h2>diskpy.ICgen.vertical_solver module<a class="headerlink" href="#module-diskpy.ICgen.vertical_solver" title="Permalink to this headline">¶</a></h2>
<p>Defines the vertical_solver class for solving vertical hydrostatic equilibrium
at a fixed radius.</p>
<p>Created on Mon Aug  3 16:01:44 2015</p>
<p>&#64;author: ibackus</p>
<dl class="function">
<dt id="diskpy.ICgen.vertical_solver.dI">
<code class="descclassname">diskpy.ICgen.vertical_solver.</code><code class="descname">dI</code><span class="sig-paren">(</span><em>I</em>, <em>dz=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/vertical_solver.html#dI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.vertical_solver.dI" title="Permalink to this definition">¶</a></dt>
<dd><p>Derivative of I with respect to z</p>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.vertical_solver.rho0">
<code class="descclassname">diskpy.ICgen.vertical_solver.</code><code class="descname">rho0</code><span class="sig-paren">(</span><em>z</em>, <em>h=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/vertical_solver.html#rho0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.vertical_solver.rho0" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate functional form for rho.  All quantities are dimensionless</p>
<p>To first order, h should equal 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z</strong> : Array</p>
<blockquote>
<div><p>z positions to estimate rho at</p>
</div></blockquote>
<p><strong>h</strong> : float</p>
<blockquote>
<div><p>dimensionless scale height.  Default=1</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rho</strong> : array</p>
<blockquote class="last">
<div><p>Dimensionless density</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.vertical_solver.setup">
<code class="descclassname">diskpy.ICgen.vertical_solver.</code><code class="descname">setup</code><span class="sig-paren">(</span><em>IC</em>, <em>R</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/vertical_solver.html#setup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.vertical_solver.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize values for solving vertical hydrostatic equlibrium.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>IC</strong> : IC object</p>
<blockquote>
<div><p>Initial conditions object</p>
</div></blockquote>
<p><strong>R</strong> : SimArray</p>
<blockquote>
<div><p>Radius at which to solve hydrostatic equilibrium</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>z</strong> : array</p>
<blockquote>
<div><p>Dimensionless z bins, in units of h</p>
</div></blockquote>
<p><strong>r</strong> : float</p>
<blockquote>
<div><p>Radius in units of h</p>
</div></blockquote>
<p><strong>c</strong> : float</p>
<blockquote>
<div><p>Constant in residual equation</p>
</div></blockquote>
<p><strong>zscale</strong> : SimArray</p>
<blockquote>
<div><p>Amount to scale z (all lengths) by to get dimensions back.
ie, Z(actual) = z*zscale</p>
</div></blockquote>
<p><strong>rhoscale</strong> : SimArray</p>
<blockquote class="last">
<div><p>Scale for dimensionless rho</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="diskpy.ICgen.vertical_solver.vertical_solver">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.vertical_solver.</code><code class="descname">vertical_solver</code><span class="sig-paren">(</span><em>IC</em>, <em>R</em>, <em>rescale_rho=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/vertical_solver.html#vertical_solver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.vertical_solver.vertical_solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the class which solves vertical hydrostatic equilibrium for a thin
Keplerian disk orbiting a central star</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IC</span> <span class="o">=</span> <span class="n">ICgen</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;IC.p&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">SimArray</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="s">&#39;au&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span> <span class="o">=</span> <span class="n">vertical_solver</span><span class="p">(</span><span class="n">IC</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s">&#39;z&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">results</span><span class="p">[</span><span class="s">&#39;rho&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>This example loads up an already created initial conditions object then
solves for hydrostatic equilibrium at R=0.5 AU</p>
<dl class="method">
<dt id="diskpy.ICgen.vertical_solver.vertical_solver.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/vertical_solver.html#vertical_solver.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.vertical_solver.vertical_solver.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to find the root of the residual of the differential equation 
for rho at all z, given the initial guess self.rho0</p>
<p>Uses a Newton&#8217;s method with the Krylov approximation for the Jacobian
(see scipy.optimize.newton_krylov)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>**kwargs</strong> : keyword arguments</p>
<blockquote>
<div><p>Additional arguments passed to the root finder
[see scipy.optimize.newton_krylov]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rho</strong> : array</p>
<blockquote class="last">
<div><p>Dimensionless density, saves it to self.rho</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.vertical_solver.vertical_solver.fitrobust">
<code class="descname">fitrobust</code><span class="sig-paren">(</span><em>nh=10</em>, <em>scansize=5</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/vertical_solver.html#vertical_solver.fitrobust"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.vertical_solver.vertical_solver.fitrobust" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to find the root of the residual of the differential equation 
for rho at all z, given the initial guess generated by different values
of h.</p>
<p>This routine is slower than fit but can avoid local minima.  If fit
doesn&#8217;t seem to be converging to the right values, consider using this.</p>
<p>h is a dimensionless disk height, which is near 1.  This algorithm
scans over values of h to create initial guesses rho0.  fit() is then
called, and the results are stored.  The fit value of rho which is
globally closest to 0 is then used.</p>
<p>Uses a Newton&#8217;s method with the Krylov approximation for the Jacobian
(see scipy.optimize.newton_krylov)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nh</strong> : int</p>
<blockquote>
<div><p>(optional) Number of h values to scan over</p>
</div></blockquote>
<p><strong>scansize</strong> : float</p>
<blockquote>
<div><p>(optional) Sets the range of h values to scan over.  Scans from 
h0/scansize to h0*scansize</p>
</div></blockquote>
<p><strong>**kwargs</strong> : keyword arguments</p>
<blockquote>
<div><p>Additional arguments passed to the root finder
[see scipy.optimize.newton_krylov]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rho</strong> : array</p>
<blockquote class="last">
<div><p>Dimensionless density, saves it to self.rho</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.vertical_solver.vertical_solver.residual">
<code class="descname">residual</code><span class="sig-paren">(</span><em>rho</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/vertical_solver.html#vertical_solver.residual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.vertical_solver.vertical_solver.residual" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the residual of the differential equation for rho for all
z</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-diskpy.ICgen">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-diskpy.ICgen" title="Permalink to this headline">¶</a></h2>
<p>Created on Fri Aug  7 10:11:48 2015</p>
<p>&#64;author: ibackus</p>
<dl class="class">
<dt id="diskpy.ICgen.IC">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.</code><code class="descname">IC</code><span class="sig-paren">(</span><em>r=None</em>, <em>sigma=None</em>, <em>CDF=None</em>, <em>profile_kind=None</em>, <em>settings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#IC"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.IC" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the IC class.</p>
<p>INITIALIZING NEW INITIAL CONDITIONS</p>
<p># Initialize a blank IC object (with no surface density profile yet made)</p>
<p>IC = ICgen.IC()</p>
<p># Initialize an IC object and surface density profile using default settings</p>
<p>IC = ICgen.IC(profile_kind=&#8217;powerlaw&#8217;)
IC = ICgen.IC(profile_kind=&#8217;MQWS&#8217;)</p>
<p># Initialize IC object from 1-D SimArrays r, sigma (surface density)</p>
<p>IC = ICgen.IC(r, sigma)</p>
<p>Optionally, the CDF for the surface density profile can be supplied to
speed up generation of sigma.  To do that:</p>
<p>IC = ICgen.IC(r, sigma, CDF)</p>
<p>Or, the input can be a the filename of a pickled dictionary containing
&#8216;r&#8217;, &#8216;sigma&#8217;, and optionally &#8216;CDF&#8217;</p>
<p>Settings can also be entered manually if needed</p>
<p>settings = pickle.load(open(&#8216;settings.p&#8217;,&#8217;r&#8217;))
IC = ICgen.IC(settings = settings)</p>
<p>GENERATING INITIAL CONDITIONS</p>
<dl class="method">
<dt id="diskpy.ICgen.IC.Qest">
<code class="descname">Qest</code><span class="sig-paren">(</span><em>r=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#IC.Qest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.IC.Qest" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate Toomre Q at r (optional) for ICs, assuming omega=epicyclic
frequency.  Ignores disk self-gravity</p>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.IC.generate">
<code class="descname">generate</code><span class="sig-paren">(</span><em>restart=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#IC.generate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.IC.generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs through all the steps to generate a set of initial conditions</p>
<p>IF restart=True, it picks up at the last completed step</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.load">
<code class="descclassname">diskpy.ICgen.</code><code class="descname">load</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/ICgen.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="diskpy.ICgen.rhosolver">
<em class="property">class </em><code class="descclassname">diskpy.ICgen.</code><code class="descname">rhosolver</code><span class="sig-paren">(</span><em>IC</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/rhosolver.html#rhosolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.rhosolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the rho class that allows the solving of vertical hydrostatic 
equilibrium over the disk, and generates callable methods for estimating
density and the normalized inverse CDF over the disk.</p>
<p class="rubric">Examples</p>
<p>Initialize rho, solve vertical equilibrium</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IC</span><span class="o">.</span><span class="n">maker</span><span class="o">.</span><span class="n">sigma_gen</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span> <span class="o">=</span> <span class="n">rhosolver</span><span class="p">(</span><span class="n">IC</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>Rho is now callable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">.</span><span class="n">cdf_inv</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>Save rho</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rho_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;z&#39;</span><span class="p">:</span> <span class="n">rho</span><span class="o">.</span><span class="n">z_bins</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">:</span> <span class="n">rho</span><span class="o">.</span><span class="n">r_bins</span><span class="p">,</span> <span class="s">&#39;rho&#39;</span><span class="p">:</span> <span class="n">rho</span><span class="o">.</span><span class="n">rho_binned</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">rho_dict</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;rhofile.p&#39;</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Load rho</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;rhofile.p&#39;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="diskpy.ICgen.rhosolver.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/rhosolver.html#rhosolver.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.rhosolver.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load/initialize from a dictionary or a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f</strong> : dict or str</p>
<blockquote class="last">
<div><p>Either a dictionary containing everything required to load rho
or a filename pointing to a pickled dictionary</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="diskpy.ICgen.rhosolver.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/rhosolver.html#rhosolver.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.rhosolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the hydrostatic vertical equilibrium for the disk to find the
density.  Also calculates the normalized inverse CDF</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kwargs :</strong></p>
<blockquote class="last">
<div><p>(optional) key word arguments to pass to the root finder
[scipy.optimize.newton_krylov]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="diskpy.ICgen.loadrho">
<code class="descclassname">diskpy.ICgen.</code><code class="descname">loadrho</code><span class="sig-paren">(</span><em>IC</em>, <em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/diskpy/ICgen/rhosolver.html#loadrho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#diskpy.ICgen.loadrho" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a rhosolver object from f (a file or dictionary) and saves it to
IC.rho</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f</strong> : dict or str</p>
<blockquote>
<div><p>Either a dictionary containing everything required to load rho
or a filename pointing to a pickled dictionary</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rho</strong> : rhosolver</p>
<blockquote class="last">
<div><p>An intialied rho solver object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">diskpy.ICgen package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.AddBinary">diskpy.ICgen.AddBinary module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.ICgen">diskpy.ICgen.ICgen module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.ICgen_settings">diskpy.ICgen.ICgen_settings module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.ICgen_utils">diskpy.ICgen.ICgen_utils module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.binary">diskpy.ICgen.binary module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.binaryUtils">diskpy.ICgen.binaryUtils module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.calc_temp">diskpy.ICgen.calc_temp module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.calc_velocity">diskpy.ICgen.calc_velocity module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.kepler38">diskpy.ICgen.kepler38 module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.make_sigma">diskpy.ICgen.make_sigma module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.make_snapshot">diskpy.ICgen.make_snapshot module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.make_snapshotBinary">diskpy.ICgen.make_snapshotBinary module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.make_snapshotSType">diskpy.ICgen.make_snapshotSType module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.make_snapshotSTypeSupplied">diskpy.ICgen.make_snapshotSTypeSupplied module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.pos_class">diskpy.ICgen.pos_class module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.rhosolver">diskpy.ICgen.rhosolver module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.sigma_profile">diskpy.ICgen.sigma_profile module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.test">diskpy.ICgen.test module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen.vertical_solver">diskpy.ICgen.vertical_solver module</a></li>
<li><a class="reference internal" href="#module-diskpy.ICgen">Module contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="diskpy.html"
                        title="previous chapter">diskpy package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="diskpy.ICgen.sigprofiles.html"
                        title="next chapter">diskpy.ICgen.sigprofiles package</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/diskpy.ICgen.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="diskpy.ICgen.sigprofiles.html" title="diskpy.ICgen.sigprofiles package"
             >next</a> |</li>
        <li class="right" >
          <a href="diskpy.html" title="diskpy package"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">diskpy  documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="diskpy.html" >diskpy package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Isaac Backus.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>